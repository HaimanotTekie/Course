// Generated with Genova.

package no.course.service.application.office.copy of addstudentstocourse.generated;

import no.course.domain.StudentCourse;
import no.course.domain.Student;

import java.io.Serializable;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.List;
import java.util.LinkedList;
import java.util.Collection;
import java.util.Iterator;

import no.genova.dataaccess.Session;
import no.genova.jgrape.DataService;
import no.genova.jgrape.DataServiceImpl;
import no.genova.jgrape.Role;
import no.genova.jgrape.trigger.JGrapeTrigger.TriggerType;
import no.genova.jgrape.trigger.TriggerInvoker;
import no.genova.service.enumerator.ENavigation;
import no.genova.domain.DomainUtil;
import no.genova.support.ObjectSelection;
import no.genova.support.ClientContext;
import no.genova.support.FindData;
import no.genova.support.TypeTool;
import no.genova.support.ActionType;
import no.genova.exception.GenovaServiceException;
import no.genova.message.Message;
import no.genova.message.MessageFactory;
import no.genova.message.MessageSystem;
import no.genova.message.CRuntimeMsg;

/**
 * The <code>StudentDefaultManager</code> class is generated by the Genova Service Generator from the object selection <code>Copy of AddStudentsToCourse</code>.
 * <p>
 * The java file containing this class should not be altered. All changes will be lost when the class is regenerated.
 * <p>
 * The class contains all methods used to manipulate the object selection role <code>student</code>
 * <p>
 * The role student data objects are of class <code>no.course.domain.Student</code>;
 * <p>
 * <code>student</code> is child role of the role <code>studentCourses</code> under the root role <code>Course</code>.
 * <br>
 * It is   owner in the association between <code>studentCourses</code> and <code>student</code>
 * <p>
 * The <code>student</code> is a leaf role in the object selection <code>Copy of AddStudentsToCourse</code>
 * <p>
 * Object selection role documentation:
 * <br>
 * 
 * <p>
 * Class documentation:
 * <br>
 * 
 */
@SuppressWarnings("all")
abstract public class StudentDefaultManager extends Role {

    /**
    * Contains the result after save/update/insert action. The parent object is the key object of this map
    */
    Map resultMap = new HashMap();


    /**
     * Hook method called at start of <code>cleanupResultAsTarget</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsTarget</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsTarget</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param rootResult The root node for the target node
     * @return true.
     */
    protected boolean hookCleanupResultAsTargetStart(Object rootResult) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsTarget</code> for role <code>student</code>.
     *
     * @param resultObject The root node for the target node
     */
    protected void hookCleanupResultAsTargetEnd(Object resultObject) {
    }

    /**
     * Hook method called at start of <code>cleanupResultAsChild</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsChild</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsChild</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The <code>StudentCourse<code> object which is parent object in tghis cleanup
     * @return true.
     */
    protected boolean hookCleanupResultAsChildStart(StudentCourse parentObject) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsChild</code> for role <code>student</code>.
     *
     * @param parentObject The <code>StudentCourse<code> object which is parent object in tghis cleanup
     */
    protected void hookCleanupResultAsChildEnd(StudentCourse parentObject) {
    }

    /**
     * Hook method called at start of <code>find</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>find</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>find</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>find</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the search data for the target.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookFindStart(ObjectSelection objectSelection,Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>find</code> for <code>student</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>findSingle</code> will return the object found without futher actions.</li>
     *    <li>null: <code>findSingle</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with search data.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookFindSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findSingle</code> will return null.</li>
     *    <li>true: <code>findSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param resultObject The <code>Student</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true
     */
    protected boolean hookFindSingleEnd(Student resultObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at start of <code>findAsRelated</code> for a <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findAsRelated</code> will return the result without futher actions.
     * The related <code>Student</code> objects are expected to be connect to the <code>StudentCourse</code> parent object.</li>
     *    <li>true: <code>findAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The database <code>StudentCourse</code> object we want to find related <code>Student</code> to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookFindAsRelatedStart(StudentCourse parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>findAsRelated</code> for a <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     *
     * @param parentObject The database <code>StudentCourse</code> object we want to find related <code>Student</code> to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindAsRelatedEnd(StudentCourse parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findAll</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>List</code> with the resulting <code>Student</code> objects: <code>findAll</code> will return the list to the client without futher actions.</li>
     *    <li>null: <code>findAll</code> will do its search for the wanted records.</li>
     *    <li>GenovaBaseException: findAll will be aborted.</li>
     * </ul>
     *
     * @param clazz The class of the target object of type <code>Student</code>.
     * @param findData The search criteria. A null reference means using default search.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null
     */
    protected List hookFindAllStart(Class clazz, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findAll</code> for <code>student</code>
     * <p>
     *
     * @param resultList The list of <code>Student</code> objects found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     */
    protected void hookFindAllEnd(List resultList, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>save</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>save</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>save</code> will do its saving for the target object.</li>
     *    <li>GenovaBaseException: <code>save</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookSaveStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>save</code> for <code>student</code>.
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object saved: <code>saveSingle</code> will return the object saved without futher actions.</li>
     *    <li>null: <code>saveSingle</code> will do the saving of the target object.</li>
     *    <li>GenovaBaseException: <code>saveSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with data to be saved.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookSaveSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>saveSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveSingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveAsRelated</code> for an up related <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>saveAsRelated</code> will return without futher actions.
     * The up related <code>Student</code> objects are expected to be saved and connect to the <code>StudentCourse</code> database parent object.</li>
     *    <li>true: <code>saveAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>saveAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connect as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookSaveAsRelatedStart(StudentCourse parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>saveAsRelated</code> for an up related <code>Student</code> object.
     * <p>
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connect as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveAsRelatedEnd(StudentCourse parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifySingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object identified: <code>identifySingle</code> will return the object identified without futher actions.</li>
     *    <li>null: <code>identifySingle</code> will do identify of the target object.</li>
     *    <li>GenovaBaseException: <code>identifySingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The Student object with data to be identified in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookIdentifySingleStart(Student object, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>identifySingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifySingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifyAsRelated</code> for an up related <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>identifyAsRelated</code> will return without futher actions.
     * The up related <code>Student</code> objects are expected to be identified and connected to the <code>StudentCourse</code> database parent object.</li>
     *    <li>true: <code>identifyAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>identifyAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookIdentifyAsRelatedStart(StudentCourse parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>identifyAsRelated</code> for an up related <code>Student</code> object.
     * <p>
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifyAsRelatedEnd(StudentCourse parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insert</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>insert</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>insert</code> will do its inserting for the target object.</li>
     *    <li>GenovaBaseException: <code>insert</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookInsertStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insert</code> for <code>student</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object saved: <code>insertSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>insertSingle</code> will do the inserting of the target object.</li>
     *    <li>GenovaBaseException: <code>insertSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookInsertSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insertSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertSingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertAsRelated</code> for an up related <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>insertAsRelated</code> will return without futher actions.
     * The up related <code>Student</code> objects are expected to be inserted and connected to the <code>StudentCourse</code> database parent object.</li>
     *    <li>true: <code>insertAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>insertAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookInsertAsRelatedStart(StudentCourse parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>insertAsRelated</code> for an up related <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertAsRelatedEnd(StudentCourse parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>update</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>update</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>update</code> will do its updating for the target object.</li>
     *    <li>GenovaBaseException: <code>update</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookUpdateStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>update</code> for <code>student</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object saved: <code>updateSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>updateSingle</code> will do the updating of the target object.</li>
     *    <li>GenovaBaseException: <code>updateSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookUpdateSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>updateSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateSingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateAsRelated</code> for an up related <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>updateAsRelated</code> will return without futher actions.
     * The up related <code>Student</code> objects are expected to be updated and connected to the <code>StudentCourse</code> database parent object.</li>
     *    <li>true: <code>updateAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>updateAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookUpdateAsRelatedStart(StudentCourse parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>updateAsRelated</code> for an up related <code>Student</code> object.
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateAsRelatedEnd(StudentCourse parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>delete</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>delete</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>delete</code> will continue.</li>
     *    <li>GenovaBaseException: <code>delete</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>delete</code> for <code>student</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was deleted.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteSingle</code> will return without futher actions.</li>
     *    <li>true: <code>deleteSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The <code>Student</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteSingleStart(Student object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteSingle</code> for an object.
     * <p>
     *
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteSingleEnd(ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteAsRelated</code> for a related <code>Student</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteAsRelated</code> will return without futher actions.
     * The related <code>Student</code> objects are expected to be deleted or disconnect from the <code>StudentCourse</code> parent object.</li>
     *    <li>true: <code>deleteAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>StudentCourse</code> with the <code>Student</code> objects connect as it is in the database before the delete.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteAsRelatedStart(StudentCourse parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteAsRelated</code> for a related <code>Student</code> object.
     * <p>
     *
     * @param parentObject The parent object <code>StudentCourse</code> as it is in the database after the delete.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteAsRelatedEnd(StudentCourse parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>connect</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>connect</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>connect</code> will continue.</li>
     *    <li>GenovaBaseException: <code>connect</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookConnectStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>connect</code> for <code>student</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookConnectEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>connectSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>connectSingle</code> will return without futher actions.</li>
     *    <li>true: <code>connectSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>connectSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param dbChildObject The <code>Student</code> object to be connected.
     * @param dbParentObject The <code>StudentCourse</code> object to be connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookConnectSingleStart(Student dbChildObject, StudentCourse dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>connectSingle</code> for an object.
     * <p>
     *
     * @param dbChildObject The <code>Student</code> object connected.
     * @param dbParentObject The <code>StudentCourse</code> object connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookConnectSingleEnd(Student dbChildObject, StudentCourse dbParentObject,ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>disconnect</code> for role <code>student</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>disconnect</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>disconnect</code> will continue.</li>
     *    <li>GenovaBaseException: <code>disconnect</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDisconnectStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>disconnect</code> for <code>student</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDisconnectEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>disconnectSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>disconnectSingle</code> will return without futher actions.</li>
     *    <li>true: <code>disconnectSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>disconnectSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param dbChildObject The <code>Student</code> object to be disconnected.
     * @param dbParentObject The <code>StudentCourse</code> object to be disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDisconnectSingleStart(Student dbChildObject, StudentCourse dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>disconnectSingle</code> for an object.
     * <p>
     *
     * @param dbChildObject The <code>Student</code> object disconnected.
     * @param dbParentObject The <code>StudentCourse</code> object disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDisconnectSingleEnd(Student dbChildObject, StudentCourse dbParentObject,ClientContext ctx, Session session) {
    }

    /**
     * Hook method called from <code>initializeRole</code>. This hook may be used to override the key
     * definitions for the role.
     * <p>
     * When overriding this hook has two possible exits:
     * <ul>
     *    <li>false: Don't do the default initialization of class' keys<li>
     *    <li>true: Do the default initialization of the class' keys<li>
     * </ul>
     *
     * @return true.
     */
    protected boolean hookInitializeKeys() {
        return true;
    }

    /**
     * Initialize this role manager.
     * The method initializes super before own initialization.
     * 
     * @param applicationName Name of the application
     * @param name Name of the role.
     * @param parent Parent role manager. It should be a <code>StudentCoursesDefaultManager</code>.
     */
    final public void initializeRole(String applicationName, String name, Role parent) {
        super.initializeRole(applicationName,name,parent);
        getIncludedAttributes().add("age");
        getExcludedAttributes().add("id");
        getIncludedAttributes().add("name");
        getIncludedAttributes().add("studentNr");
        if (hookInitializeKeys()) {
            Key key;
            key = addKey("id",true,true);
            key.addAttribute("id");
        }
        resultMap.clear();
    }

    /**
     * Check if two <code>Student<code> objects are identical.
     * They are identical if all attributes are equals() ( == for primitives) and
     * all uprelated points to the same objects
     *
     * @param firstObject The first <code>Student</code> object.
     * @param secondObject The second <code>Student</code> object.
     * @return true if the objects are identical
     */
    public boolean isIdentical(Student firstObject, Student secondObject) {
        boolean identical = true;
        if (firstObject != null && secondObject != null && firstObject != secondObject) {
           if (identical) {
               identical = firstObject.getAge() == secondObject.getAge();
           }
           if (identical) {
               identical = firstObject.getId() == secondObject.getId();
           }
           if (identical) {
               Object a1 = firstObject.getName();
               Object a2 = secondObject.getName();
               identical = (a1 != null) ? a1.equals(a2) : a2 == null;
           }
           if (identical) {
               identical = firstObject.getStudentNr() == secondObject.getStudentNr();
           }
        }
        else {
           identical = firstObject == secondObject;
        }
        return identical;
    }

    /**
     * Copy all attributes between two <code>Student</code> objects.
     * The method copies the lock flag too, if the dbms implementation is with optimistic locking.
     *
     * @param fromObject The <code>Student</code> object to copy from.
     * @param toObject The <code>Student</code> object to copy to.
     * @param includedOnly true: Copy only attributes included in this object selection role.
     *                     false: Copy excludede attributes also.
     */
    final void copyAttributes(Student fromObject, Student toObject, boolean includedOnly) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
            toObject.setAge(fromObject.getAge());
            if (!includedOnly) {
                toObject.setId(fromObject.getId());
            }
            toObject.setName(fromObject.getName());
            toObject.setStudentNr(fromObject.getStudentNr());
            DomainUtil.setLockFlag(toObject,DomainUtil.getLockFlag(fromObject));
        }
    }

    /**
     * Copy references to associated objects between two <code>Student</code> objects.
     * The method copies the reference to the parent object if this role is a member role
     * of its parent and the association is navigable to the parent.
     * The method copies the reference to all child objects if this role is a member role
     * of its child. In this case the association will always be navigable to the child.
     *
     * @param fromObject The <code>Student</code> object to copy from
     * @param toObject The <code>Student</code> object to copy to
     */
    final void copyRelatedOwners(Student fromObject, Student toObject) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
        }
    }

    /**
     * Generate a new <code>Student</code> object
     *
     * @return the new <code>Student</code> object
     */
    final Student newStudent() {
        Student object = new Student();
        return object;
    }

    /**
     * Clone a <code>Student</code> object. The method copies
     * attributes using <code>copyAttributes</code> and references to associated
     * objects using <code>copyRelatedOwners</code>. Other object references are
     * not copied.
     *
     * @param object The <code>Student</code> object to clone
     * @return The new <code>Student</code> object
     */
    final Student cloneObject(Student object) {
        Student newObject = null;
        if (object != null) {
            newObject = newStudent();
            copyAttributes(object,newObject,false);
            copyRelatedOwners(object,newObject);
            if (newObject.getStudentCourses() == null) {
                Set<StudentCourse> tmp = TypeTool.getDefaultSet();
                newObject.setStudentCourses(tmp);
            }
        }
        return newObject;
    }

    /**
     * For this object selection role find the root roles data object in the
     * <code>ObjectSelection</code>.
     * If the root object is a Collection with more than one object, the first
     * object in the Collection is returned.
     *
     * @param objectSelection <code>ObjectSelection</code> to search for the root object
     * @return The <code>Course</code> object
     */
    final Object findRootObject(ObjectSelection objectSelection) {
        Object rootObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("student")) {
                Collection roots = objectSelection.getRootObjects("student");
                if (roots != null) {
                    Iterator iter = roots.iterator();
                    if (iter.hasNext()) {
                        rootObject = iter.next();
                    }
                }
            }
            else if (getParent() != null) {
                rootObject = ((StudentCoursesDefaultManager)getParent()).findRootObject(objectSelection);
            }
        }
        return rootObject;
    }

    /**
     * Find target object in <code>ObjectSelection</code>.
     * The target object is either a domain object or a Collection of such objects.
     *
     * @param objectSelection The <code>ObjectSelection</code> to search.
     * @return Either a single target object or a <code>Collection</code> of target objects.
     */
    final Object findTargetObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("student")) {
                resultObject = objectSelection.getRootObjects("student");
                if (!(objectSelection.getTargetRoleName().equals("student")) && resultObject != null) {
                    Iterator iter = ((Collection)resultObject).iterator();
                    resultObject = iter.hasNext() ? iter.next() : null;
                }
            }
            else if (getParent() != null) {
                StudentCourse parentObject = (StudentCourse)((StudentCoursesDefaultManager)getParent()).findTargetObject(objectSelection);
                if (parentObject != null)
                {
                    resultObject = parentObject.getStudent();
                }
            }
        }
        return resultObject;
    }

    /**
     * Find parent object in an <code>ObjectSelection</code> for this role.
     * If the parent instance is inside a collection the method expects
     * this collection to contain one and only one occurence of the parent objects
     *
     * @param objectSelection The <code>ObjectSelection></code> to search
     * @return The parent <code>StudentCourse</code> object
     */
    final StudentCourse findParentObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null && getParent() != null) {
            String tmp = objectSelection.getTargetRoleName();
            objectSelection.setTargetRoleName("studentCourses");
            resultObject = ((StudentCoursesDefaultManager)getParent()).findTargetObject(objectSelection);
            if (resultObject != null && (resultObject instanceof Collection)) {
                Iterator iter = ((Collection)resultObject).iterator();
                resultObject = iter.hasNext() ? (StudentCourse)(iter.next()) : null;
            }
            objectSelection.setTargetRoleName(tmp);
        }
        return (StudentCourse)resultObject;
    }

    /**
     * Check if a <code>Student</code> object is child to a parent <code>StudentCourse</code> object.
     *
     * @param parentObject The parent <code>StudentCourse</code> 
     * @param childObject The child <code>Student</code> 
     * @param session The <code>DataAccess</code> <code>Session</code>.
     *
     * @return true if childObject is a child of parentObject.
     */
    final boolean isChildPresent(StudentCourse parentObject,Student childObject,Session session) {
        boolean present = false;
        DataService dataService = DataServiceImpl.getDataServiceImpl();
        dataService.findAssociated(parentObject.getStudent(),session);
        present = parentObject.getStudent() == childObject;
        return present;
    }

    /**
     * Make a connection from a parent <code>StudentCourse</code> to a child <code>Student</code>.
     *
     * @param parentObject The <code>StudentCourse</code> who is owner in the association
     * @param childObject The <code>Student</code> who is member in the association
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void connectFromParent(StudentCourse parentObject,Student childObject,Session session) {
        if (parentObject != null && childObject != null && !isChildPresent(parentObject,childObject,session)) {
            parentObject.setStudent(childObject);
        }
    }
    /**
     * Disconnect a child <code>Student</code> from its parent <code>StudentCourse</code>.
     *
     * @param parentObject The <code>StudentCourse</code> who is owner in the association
     * @param childObject The <code>Student</code> who is member in the association
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void disconnectFromParent(StudentCourse parentObject,Student childObject,Session session) {
        if (parentObject != null && childObject != null && isChildPresent(parentObject,childObject,session)) {
            parentObject.setStudent(null);
        }
    }


    /**
     * Get current object from the result
     * This method is only when this role is above the target role, i.e. it assumes that there
     * is only one member in each collection from the root to this object
     *
     * @param rootResult The Object which is top node in the result
     */
    Student getCurrentObject(Object rootResult) {
        Student thisObject = null;
        if (getParent() != null) {
            StudentCourse parentObject = ((StudentCoursesDefaultManager)getParent()).getCurrentObject(rootResult);
            if (parentObject != null) {
                thisObject = parentObject.getStudent();
            }
        }
        return thisObject;
    }

    /**
     * Do cleanup of result before sending it to the client. The cleanup will remove unneeded objects
     * to reduce the datatransfer between the server and the client.
     * This method is the entrypoint for cleanup after an insert/update/save with this role as target.
     * For each result root object in the result it will use cleanupAsTarget to remove unneeded objects.
     *
     * @param rootResult The Object who is the top of the path to target
     */
    public void cleanupResult(Object rootResult) {
        if (rootResult instanceof Collection) {
            Iterator iter = ((Collection)rootResult).iterator();
            while (iter.hasNext()) {
                cleanupResultAsTarget((Object)iter.next());
            }
        }
        else
        {
            cleanupResultAsTarget(rootResult);
        }
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for one result root object. For objects on the path to target it will remove
     * all downrelated children, but it will keep any uprelated children. For the target node itself it will
     * only keep those objects actually updated.
     *
     * @param rootResult The object which is the top of the path to target
     */
    public void cleanupResultAsTarget(Object rootResult) {
        if (hookCleanupResultAsTargetStart(rootResult)) {
        }
        hookCleanupResultAsTargetEnd(rootResult);
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for all related objects below the the target object in the object selction.
     *
     * @param parentObject The <code>StudentCourse</code> object who is parent to the objects processed. 
     */
    public void cleanupResultAsChild(StudentCourse parentObject) {
        if (hookCleanupResultAsChildStart(parentObject)) {
            if ((getCurrentObjectSelection().getDoOneRelated())) {
                if (parentObject != null) {
                }
            } else {
                parentObject.setStudent(null);
            }
        }
        hookCleanupResultAsChildEnd(parentObject);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and searches for a target object of class <code>Student</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will use the main key to find the <code>Student</code> object.
     * <p>
     *
     * @param objectSelection The object selection with all search criteria.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object find(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object rootObject = null;
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject = null;
        Collection targetObjects = null;
        if (getParent() != null) {
            targetObject = (Student)findTargetObject(objectSelection);
        } else {
            targetObjects = (Collection)findTargetObject(objectSelection);
        }
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            if (iter.hasNext()) {
                targetObject = (Student)iter.next();
            }
        }
        resultObject = hookFindStart(objectSelection,targetObject,ctx,session);
        if (resultObject == null) {
            StudentCourse parentObject = null;
            if (getParent() != null) {
                parentObject = findParentObject(objectSelection);
            }
            resultObject = findSingle(targetObject,objectSelection.getTargetMainKey(),objectSelection.getFindData(),ctx,session);
            if (parentObject != null) {
                parentObject.setStudent(resultObject);
            }
            if (getParent() == null) {
                if (resultObject != null) {
                    rootList.add(resultObject);
                }
            }
            else {
                rootObject = findRootObject(objectSelection);
                rootList.add(rootObject);
            }
            hookFindEnd(objectSelection,resultObject,ctx,session);
        }
        return rootList;
    }

    /**
     * Find a single <code>Student</code> object in the database.
     * <p>
     * The method uses the search criteria defined in the <code>findData</code> parameter. Without any <code>findData</code>,
     * the method uses the targetKey to find the <code>Student</code> object. The targetKey must be a unique attribute or group.
     * Without any targetKey the main key is chosen as the first unique key found where the all attributes are part of the
     * object selection. The unique keys are examined in the following sequence:
     * <ul>
     *     <li> The primary key
     *     <li> Attributes specified as unique
     *     <li> Groups specified as unique
     * </ul>
     *
     * @param targetObject The target <code>Student</code> object with the key attributes.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object found.
     */
    public Student findSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = hookFindSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            Class clazz = Student.class;
            List keyAttributes = null;
            String primaryKey = getPrimaryKey();
            if (targetKey != null) {
                keyAttributes = getKeyAttributes(targetKey);
                if (primaryKey != null && !(primaryKey.equals(targetKey))) {
                    primaryKey = null;
                }
            }
            else {
                keyAttributes = getKeyAttributes(primaryKey != null ? primaryKey : getMainKey());
            }
            if (primaryKey == null && keyAttributes == null && findData == null) {
                Object[] args = { "Student", "Copy of AddStudentsToCourse" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NO_KEY_DEFINED, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            if (findData != null || targetObject != null) {
                if (primaryKey != null) {
                    Serializable keyObject;
                    if (primaryKey.equals("id")) {

                        keyObject = targetObject != null ? (Serializable)TypeTool.toObject(targetObject.getId()) : null;
                        if (keyObject != null || findData != null) {
                            resultObject = (Student)dataService.find(clazz,keyObject,findData,session);
                        }
                    }
                    else {
                        resultObject = (Student)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                    }
                }
                else {
                    resultObject = (Student)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                }
            }
        }
        if (!hookFindSingleEnd(resultObject,ctx,session)) {
            resultObject = null;
        }
        return resultObject;
    }

    /**
     * From a parent <code>StudentCourse</code> object find all related objects of the role <code>student</code>.
     *
     * @param parentObject The <code>StudentCourse</code> object.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void findAsRelated(StudentCourse parentObject, ClientContext ctx, Session session) {
        if (hookFindAsRelatedStart(parentObject,ctx,session)) {
            if (parentObject != null) {
                DataService dataService = DataServiceImpl.getDataServiceImpl();
                dataService.findAssociated(parentObject.getStudent(),session);
            }
        }
        hookFindAsRelatedEnd(parentObject,ctx,session);
    }
    /**
     * This method is part of the <code>Manager</code> Interface and finds all target objects of class <code>Student</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will return all occurences of <code>Student</code>. Each <code>Student</code> object
     * returned will also contain all uprelated child objects. 
     *
     * @param objectSelection The object selection
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return List of <code>Student</code> objects found.
     */
    public List<?> findAll(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        if (objectSelection.getFindData() != null && (objectSelection.getFindData().getDeepFindAll())) {
            objectSelection.setDoOneRelated(true);
            objectSelection.setDoFirstLevelManyRelated(true);
            objectSelection.setDoAnyLevelManyRelated(true);
        }
        List resultList = null;
        Class clazz = Student.class;
        resultList = hookFindAllStart(clazz,objectSelection.getFindData(),ctx,session);
        if (resultList == null) {
            Student targetObject = null;
            Collection targetObjects = null;
            if (getParent() != null) {
                targetObject = (Student)findTargetObject(objectSelection);
            } else {
                targetObjects = (Collection)findTargetObject(objectSelection);
            }
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                if (iter.hasNext()) {
                    targetObject = (Student)iter.next();
                }
            }
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            resultList = dataService.findAll(clazz,targetObject,objectSelection.getFindData(),session);
        }
        hookFindAllEnd(resultList,ctx,session);
        return resultList;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and saves a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object save(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object[] rootObject = new Object[1];
        StudentCourse clientParentObject = null;
        StudentCourse dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (StudentCourse)findParentObject(objectSelection);
        }
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject;
        Collection targetObjects = null;
        if (getParent() != null) {
            targetObjects = new LinkedList();
            targetObject = (Student)findTargetObject(objectSelection);
            if (targetObject != null) {
                targetObjects.add(targetObject);
            }
        } else {
            targetObjects = (Collection)findTargetObject(objectSelection);
        }
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                ActionType action = ActionType.SAVE;
                if (objectSelection.getActions() != null) {
                    action = (ActionType)(objectSelection.getActions().get(targetObject));
                    if (action == null) action = ActionType.SAVE;
                }
                switch (action) {
                    case SAVE:
                        resultObject = save(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case INSERT:
                        resultObject = insert(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case UPDATE:
                        resultObject = update(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case DELETE:
                        delete(targetObject, clientParentObject, dbParentObject, ctx, session);
                        resultObject = null;
                        break;
                    case CONNECT:
                        if (getParent() != null) {
                            resultObject = connect(targetObject, clientParentObject, dbParentObject, ctx, session);
                        }
                        break;
                    case DISCONNECT:
                        if (getParent() != null) {
                            disconnect(targetObject, clientParentObject, dbParentObject, ctx, session);
                        }
                        resultObject = null;
                        break;
                    default:
                    {
                        Object[] args = { action.name() };
                        Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UNKNOWN_SERVICE_ACTION, args);
                        MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                        throw new GenovaServiceException(msg);
                    }
                }
                if (resultObject != null) {
                    if (getParent() == null) {
                        rootList.add(resultObject);
                    } else {
                        resultMap.put(clientParentObject,resultObject);
                    }
                }
            }
        }
        if (getParent() != null) {
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Save one <code>Student</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the database.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param clientParentObject The <code>StudentCourse</code> object as sent from the client.
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated/inserted into the database.
     */
    public Student save(Student targetObject, StudentCourse clientParentObject, StudentCourse dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Student resultObject;
        resultObject = hookSaveStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = saveSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (clientParentObject != null) {
                    clientParentObject.setStudent(resultObject);
                }
            }
        }
        hookSaveEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Save a single <code>Student</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the databse.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated/inserted into the database.
     */
    public Student saveSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = null;
        resultObject = hookSaveSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                resultObject = updateSingle(targetObject,targetKey,findData,ctx,session);
            }
            else {
                resultObject = insertSingle(targetObject,targetKey,findData,ctx,session);
            }
        }
        hookSaveSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>StudentCourse</code> object save all related <code>Student</code> objects.
     *
     * @param parentObject The <code>StudentCourse</code> object with it's child <code>Student</code> objects as recieved from the client.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void saveAsRelated(StudentCourse parentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        if (hookSaveAsRelatedStart(parentObject,ctx,session)) {
            Student childObject = parentObject.getStudent();
            if (childObject != null) {
                Student resultChildObject;
                resultChildObject = saveSingle(childObject,null,null,ctx,session);
                resultMap.put(parentObject,resultChildObject);
                if (parentObject != null) {
                    parentObject.setStudent(resultChildObject);
                }
            }
            else
            {
                Object[] args = { "StudentCourse", "Student", "Copy of AddStudentsToCourse" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_MISSING_RELATED_OBJECT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookSaveAsRelatedEnd(parentObject,ctx,session);
    }

    /**
     * Identify a single <code>Student</code> object in the database.
     * <p>
     * If the target object does not exist in the database an exception in thrown.
     *
     * @param object The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as it is in the database.
     */
    public Student identifySingle(Student object,ClientContext ctx,Session session)
    {
        Student resultObject = hookIdentifySingleStart(object,ctx,session);
        if (resultObject == null) {
            resultObject = (Student)cloneObject(object);
            resultObject = findSingle(resultObject,null,null,ctx,session);
            if (resultObject == null) {
                Object[] args = { "Student", "Copy of AddStudentsToCourse" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_IDENTIFY_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookIdentifySingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>StudentCourse</code> object identify all related <code>Student</code> objects.
     *
     * @param parentObject The <code>StudentCourse</code> object with it's child <code>Student</code> objects as recieved from the client.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void identifyAsRelated(StudentCourse parentObject, boolean setsContainAllRelated ,ClientContext ctx, Session session) {
        if (hookIdentifyAsRelatedStart(parentObject,ctx,session)) {
            Student childObject = parentObject.getStudent();
            if (childObject != null) {
                Student resultChildObject;
                resultChildObject = identifySingle(childObject,ctx,session);
                resultMap.put(parentObject,resultChildObject);
                if (parentObject != null) {
                    parentObject.setStudent(resultChildObject);
                }
            }
            else
            {
                Object[] args = { "StudentCourse", "Student", "Copy of AddStudentsToCourse" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_MISSING_RELATED_OBJECT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookIdentifyAsRelatedEnd(parentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and inserts a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object insert(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object[] rootObject = new Object[1];
        StudentCourse clientParentObject = null;
        StudentCourse dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (StudentCourse)findParentObject(objectSelection);
        }
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject;
        Collection targetObjects = null;
        if (getParent() != null) {
            targetObjects = new LinkedList();
            targetObject = (Student)findTargetObject(objectSelection);
            if (targetObject != null) {
                targetObjects.add(targetObject);
            }
        } else {
            targetObjects = (Collection)findTargetObject(objectSelection);
        }
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                resultObject = insert(targetObject, clientParentObject, dbParentObject, ctx, session);
                if (getParent() == null) {
                    rootList.add(resultObject);
                } else {
                    resultMap.put(clientParentObject,resultObject);
                }
            }
        }
        if (getParent() != null) {
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Insert one <code>Student</code> object and its related objects.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param clientParentObject The <code>StudentCourse</code> object as sent from the client.
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as inserted into the database.
     */
    Student insert(Student targetObject, StudentCourse clientParentObject, StudentCourse dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Student resultObject;
        resultObject = hookInsertStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = insertSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (clientParentObject != null) {
                    clientParentObject.setStudent(resultObject);
                }
            }
        }
        hookInsertEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Insert a single <code>Student</code> object into the database.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated into the database.
     */
    public Student insertSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
        if (!isIdentical(targetObject,resultObject)) {
            Student tmpObject = hookInsertSingleStart(targetObject,targetKey,findData,ctx,session);
            if (tmpObject == null) {
                if (resultObject == null) {
                    resultObject = cloneObject(targetObject);
                    DomainUtil.setLockFlag(resultObject,null);
                    DataService dataService = DataServiceImpl.getDataServiceImpl();
                    dataService.insert(resultObject,session); 
                }
                else {
                    Object[] args = { "Student", "Copy of AddStudentsToCourse" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_INSERT_ON_EXISTING, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
            }
            else {
              resultObject = tmpObject;
            }
            TriggerInvoker.invoke(resultObject,TriggerType.INSERT, getCurrentObjectSelection().getTargetRoleName().equals("student"), ctx, session);
            hookInsertSingleEnd(resultObject,ctx,session);
        }
        return resultObject;
    }

    /**
     * From a <code>StudentCourse</code> object insert all related <code>Student</code> objects.
     *
     * @param parentObject The <code>StudentCourse</code> object with it's child <code>Student</code> objects as recieved from the client.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void insertAsRelated(StudentCourse parentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        if (hookInsertAsRelatedStart(parentObject,ctx,session)) {
            Student childObject = parentObject.getStudent();
            if (childObject != null) {
                Student resultChildObject;
                resultChildObject = insertSingle(childObject,null,null,ctx,session);
                resultMap.put(parentObject,resultChildObject);
                if (parentObject != null) {
                    parentObject.setStudent(resultChildObject);
                }
            }
            else
            {
                Object[] args = { "StudentCourse", "Student", "Copy of AddStudentsToCourse" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_MISSING_RELATED_OBJECT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookInsertAsRelatedEnd(parentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and updates a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object update(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object[] rootObject = new Object[1];
        StudentCourse clientParentObject = null;
        StudentCourse dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (StudentCourse)findParentObject(objectSelection);
        }
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject;
        Collection targetObjects = null;
        if (getParent() != null) {
            targetObjects = new LinkedList();
            targetObject = (Student)findTargetObject(objectSelection);
            if (targetObject != null) {
                targetObjects.add(targetObject);
            }
        } else {
            targetObjects = (Collection)findTargetObject(objectSelection);
        }
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                resultObject = update(targetObject, clientParentObject, dbParentObject, ctx, session);
                if (getParent() == null) {
                    rootList.add(resultObject);
                } else {
                    resultMap.put(clientParentObject,resultObject);
                }
            }
        }
        if (getParent() != null) {
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Update one <code>Student</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param clientParentObject The <code>StudentCourse</code> object as sent from the client.
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated in the database.
     */
    Student update(Student targetObject, StudentCourse clientParentObject, StudentCourse dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Student resultObject;
        resultObject = hookUpdateStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = updateSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (clientParentObject != null) {
                    clientParentObject.setStudent(resultObject);
                }
            }
        }
        hookUpdateEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }


    /**
     * Update a single <code>Student</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated into the database.
     */
    public Student updateSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = null;
        resultObject = hookUpdateSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                if (!isIdentical(targetObject,resultObject)) {
                    if (DomainUtil.hasLockFlag(resultObject)) {
                        Serializable targetFlag = DomainUtil.getLockFlag(targetObject);
                        Serializable resultFlag = DomainUtil.getLockFlag(resultObject);
                        if (targetFlag == null || (!(DomainUtil.equalsLockFlag(targetFlag,resultFlag)))) {
                            Object[] args = { "Student" };
                            Message msg = MessageSystem.getMessageFactory().getMessage(targetFlag == null ? CRuntimeMsg.SM_NO_LOCKFLAG_VALUE : CRuntimeMsg.SM_UPDATED_BY_ANOTHER_USER, args);
                            MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                            throw new GenovaServiceException(msg);
                        }
                   }
                   copyAttributes(targetObject,resultObject,true);
                   copyRelatedOwners(targetObject,resultObject);
                }
                TriggerInvoker.invoke(resultObject,TriggerType.UPDATE, getCurrentObjectSelection().getTargetRoleName().equals("student"), ctx, session);
            }
            else {
                Object[] args = { "Student", "Copy of AddStudentsToCourse" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UPDATE_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookUpdateSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>StudentCourse</code> object update all related <code>Student</code> objects.
     *
     * @param parentObject The <code>StudentCourse</code> object with it's child <code>Student</code> objects as recieved from the client.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void updateAsRelated(StudentCourse parentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        if (hookUpdateAsRelatedStart(parentObject,ctx,session)) {
            Student childObject = parentObject.getStudent();
            if (childObject != null) {
                Student resultChildObject;
                resultChildObject = updateSingle(childObject,null,null,ctx,session);
                resultMap.put(parentObject,resultChildObject);
                if (parentObject != null) {
                    parentObject.setStudent(resultChildObject);
                }
            }
            else
            {
                Object[] args = { "StudentCourse", "Student", "Copy of AddStudentsToCourse" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_MISSING_RELATED_OBJECT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookUpdateAsRelatedEnd(parentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and deletes a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object delete(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object[] rootObject = new Object[1];
        StudentCourse clientParentObject = null;
        StudentCourse dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (StudentCourse)findParentObject(objectSelection);
        }
        List rootList = new LinkedList();
        Student targetObject;
        Collection targetObjects = null;
        if (getParent() != null) {
            targetObjects = new LinkedList();
            targetObject = (Student)findTargetObject(objectSelection);
            if (targetObject != null) {
                targetObjects.add(targetObject);
            }
        } else {
            targetObjects = (Collection)findTargetObject(objectSelection);
        }
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                delete(targetObject,clientParentObject,dbParentObject,ctx,session);
            }
        }
        if (getParent() != null) {
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Delete a single <code>Student</code> object and all it's related objects in the database.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param clientParentObject The <code>StudentCourse</code> object as sent from the client.
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void delete(Student targetObject,StudentCourse clientParentObject,StudentCourse dbParentObject,ClientContext ctx,Session session) {
        Student resultObject = null;
        if (hookDeleteStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            deleteSingle(resultObject,ctx,session);
            if (getParent() != null) {
            }
        }
        hookDeleteEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Delete a single <code>Student</code> object in the database.
     *
     * @param object The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteSingle(Student object,ClientContext ctx,Session session) {
        if (hookDeleteSingleStart(object,ctx,session)) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            dataService.delete(object,session);
            TriggerInvoker.invoke(object,TriggerType.DELETE, getCurrentObjectSelection().getTargetRoleName().equals("student"), ctx, session);
        }
        hookDeleteSingleEnd(ctx,session);
    }

    /**
     * From a <code>StudentCourse</code> object delete all related <code>Student</code> objects.
     * This role is an owner in the association to the parent. The object will not be deleted but only disconnected from the parent
     *
     * @param parentObject The <code>StudentCourse</code> object with it's child <code>Student</code> objects as it is in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteAsRelated(StudentCourse parentObject, ClientContext ctx, Session session) {
        if (hookDeleteAsRelatedStart(parentObject,ctx,session)) {
            if (parentObject != null) {
                Student childObject = parentObject.getStudent();
                if (childObject != null) {
                    childObject.getStudentCourses().remove(parentObject);
                }
            }
        }
        hookDeleteAsRelatedEnd(parentObject,ctx,session);
    }


    /**
     * This method is part of the <code>Manager</code> Interface and connects a target object of class <code>Student</code> to its parent node <code>StudentCourse.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object connect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object[] rootObject = new Object[1];
        StudentCourse clientParentObject = null;
        StudentCourse dbParentObject = null;
        List rootList = new LinkedList();
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (StudentCourse)findParentObject(objectSelection);
            Student targetObject;
            Student resultObject;
            Collection targetObjects = null;
            targetObjects = new LinkedList();
            targetObject = (Student)findTargetObject(objectSelection);
            if (targetObject != null) {
                targetObjects.add(targetObject);
            }
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                while (iter.hasNext()) {
                    targetObject = (Student)iter.next();
                    resultObject = connect(targetObject,clientParentObject,dbParentObject,ctx,session);
                    resultMap.put(clientParentObject,resultObject);
                }
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Connect a single <code>Student</code> object to its parent <code>StudentCourse object.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param clientParentObject The <code>StudentCourse</code> object as sent from the client.
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public Student connect(Student targetObject,StudentCourse clientParentObject,StudentCourse dbParentObject,ClientContext ctx,Session session) {
        Student resultObject = null;
        if (hookConnectStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            connectSingle(resultObject,dbParentObject,ctx,session);
        }
        hookConnectEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Connect a single <code>Student</code> object from its parent StudentCourse in the database.
     *
     * @param dbChildObject The <code>Student</code> object as found in the database
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void connectSingle(Student dbChildObject,StudentCourse dbParentObject,ClientContext ctx,Session session) {
        if (hookConnectSingleStart(dbChildObject,dbParentObject,ctx,session)) {
            if (dbParentObject != null && dbChildObject != null) {
                dbChildObject.getStudentCourses().add(dbParentObject);
                dbParentObject.setStudent(dbChildObject);
            }
        }
        hookConnectSingleEnd(dbChildObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and disconnects a target object of class <code>Student</code> from its parent node <code>StudentCourse.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object disconnect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object[] rootObject = new Object[1];
        StudentCourse clientParentObject = null;
        StudentCourse dbParentObject = null;
        List rootList = new LinkedList();
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (StudentCourse)findParentObject(objectSelection);
            Student targetObject;
            Collection targetObjects = null;
            targetObjects = new LinkedList();
            targetObject = (Student)findTargetObject(objectSelection);
            if (targetObject != null) {
                targetObjects.add(targetObject);
            }
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                while (iter.hasNext()) {
                    targetObject = (Student)iter.next();
                    disconnect(targetObject,clientParentObject,dbParentObject,ctx,session);
                }
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Disconnect a single <code>Student</code> object from its parent <code>StudentCourse object.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param clientParentObject The <code>StudentCourse</code> object as sent from the client.
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void disconnect(Student targetObject,StudentCourse clientParentObject,StudentCourse dbParentObject,ClientContext ctx,Session session) {
        Student resultObject = null;
        if (hookDisconnectStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            disconnectSingle(resultObject,dbParentObject,ctx,session);
        }
        hookDisconnectEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Disconnect a single <code>Student</code> object from its parent StudentCourse in the database.
     *
     * @param dbChildObject The <code>Student</code> object as found in the database
     * @param dbParentObject The <code>StudentCourse</code> object as found in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void disconnectSingle(Student dbChildObject,StudentCourse dbParentObject,ClientContext ctx,Session session) {
        if (hookDisconnectSingleStart(dbChildObject,dbParentObject,ctx,session)) {
            if (dbParentObject != null && dbChildObject != null) {
                dbChildObject.getStudentCourses().remove(dbParentObject);
                dbParentObject.setStudent(null);
            }
        }
        hookDisconnectSingleEnd(dbChildObject,dbParentObject,ctx,session);
    }
   
    /**
     * This method is part of the <code>Manager</code> Interface and gets the target <code>Student</code> object the database.
     *
     * @param objectSelection The <code>ObjectSelection</code> containing the data from the client.
     * @param navigation
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return Object
     */
    public Object get(ObjectSelection objectSelection, ENavigation navigation, ClientContext ctx, Session session) {
        return null;
    }
}
