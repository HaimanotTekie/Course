// ---------------------------------------------------------------------
// Generated with Genova.
// ---------------------------------------------------------------------
    
    /* Her kommer generert kode for Listblock:ListblockLineClass*/
    
    
package no.course.dialog.course;

import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import javax.swing.JComboBox;
import javax.swing.JCheckBox;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import javax.swing.SwingConstants;
import javax.swing.JComponent;
import java.util.Enumeration;
import java.io.Serializable;
import javax.swing.event.AncestorListener;
import javax.swing.event.AncestorEvent;

import no.course.domain.Course;


/**
 * The following imports are known to be used. To avoid potentially
 * errors due to lack of imports no.genova.client.support.*; 
 * is added last.
 */ 
import no.genova.client.support.ListblockLine;
import no.genova.client.component.GenovaComboBox;
import no.genova.client.support.*;

import no.genova.domain.DomainUtil;
import no.genova.domain.DomainProxy;
import no.genova.domain.DomainObjectProxy;

import no.genova.exception.GenovaClientException;

import no.genova.message.CRuntimeMsg;
import no.genova.message.Message;

/*
 * The following imports are known to be used. To avoid potentially
 * errors due to lack of imports no.genova.support.*; 
 * is added last.
 */ 
import no.genova.support.TypeTool;
import no.genova.support.Numeric;
import no.genova.domain.DomainUtil;
import no.genova.support.*;

/** Class for holding one line of information for the listblock
 * StudentCourses2List.
 *
 * <p><strong>State handling in listblock</strong></p> A listblock
 * line has three different states new, deleted and changed. If a
 * line has gotten a given state, it will keep that state until
 * the state is cleared or become reset. The transitions from 'no'
 * state are:
 *
 * <ul>
 * <li>new : A listblock line is flagged as new after it has been inserted into the listblock.
 * <li>changed: A listblock line is edited by the user.
 * <li>deleted: Call to delete listblock method.
 * </ul>
 * Upon startup of a dialog, after filling its content, normal use
 * would be to perform forceClean() to zero all state.
 *
 * <p><strong>Undo support</strong></p>
 *
 * A listblock line has one level of undo. When the method reset()
 * is called the 'current' data will be copied to the 'old'. In
 * each line there are getters for both the current data and the
 * old data. To restore the previous state of a listblock line, use the method
 * previousState().
 *
 */
@SuppressWarnings("all")
public class LineListblockStudentCourses2List implements ListblockLine {
    HashMap cellObjects = new HashMap();

    // key = roleName, value = object
    private Map roleNameToObject = new HashMap();

    /**
     * Returns the object used for editing at a given column. The
     * object currently available for getting like this would be
     * the checkboxes used for editing and displaying booleans.
     * @return The editor object of null if none on that column number.
     * @param column The column number to get the editor for, zero if none.
     */
    public Object getCellObject(int column) {
        column = ((Integer)controller.view.StudentCourses2List_indexes.elementAt(column)).intValue();
        return cellObjects.get(new Integer(column));
    }

    /** Internal use */
    class CheckItemListener implements ItemListener {
        /** Internal use.
         * @param e Internal use.
         */
        public void itemStateChanged(ItemEvent e) { 
            /* Silence code checkers */
            if(false) {e.getClass(); }
        }
    }

    /** Internal use */
    final LineListblockStudentCourses2List pointerToListblockLine = this;

    CourseDefaultController controller;

    DomainProxy domainProxy;
    private boolean ischanged;
    private boolean isnew;
    private boolean isdeleted;
    private boolean isdisabled;

    private boolean oldIschanged;
    private boolean oldIsnew;
    private boolean oldIsdeleted;

    int lineNumber;

    /** Do not use this constructor! Use insert methods on the
     *     variable listblockMethodsStudentCourses2List! 
     * @param c Internal use.
     */
    LineListblockStudentCourses2List(CourseDefaultController c) {
        controller = c;
        domainProxy = new DomainProxy(true, controller.applicationEnums);
    }

    /**
     * Returns true if the line in the listblock StudentCourses2List is deleted 
     * See documentation about state on class LineListblockStudentCourses2List.
     * @return True if deleted, false if not.
     */
    public boolean isDeleted() {
        return isdeleted;
    }

    /**
     * Returns true if the line in the listblock StudentCourses2List is disabled 
     * See documentation about state on class LineListblockStudentCourses2List.
     * @return True if disabled, false if not.
     */
    public boolean isDisabled() {
       return isdisabled;
    }

    /** Returns true if the line in the listblock StudentCourses2List is new.
     * @return Ture if new, false if not.
     */
    public boolean isNew() {
        return isnew;
    }

    /**
     * Returns true if the line in the listblock StudentCourses2List is changed 
     * See documentation about state on class LineListblockStudentCourses2List.
     * @return True if changed, false if not.
     */
    public boolean isChanged() {
        return ischanged;
    }

    /** 
     * Returns true if the line in the listblock StudentCourses2List was
     * deleted last time reset was called.
     * See documentation about state on class LineListblockStudentCourses2List.
     * @return True if deleted, false if not.
     */
    public boolean oldIsDeleted() {
        return oldIsdeleted;
    }

    /**
     * Returns true if the line in the listblock StudentCourses2List had the status
     * new last time reset was called.
     * @return True if new, false if not.
     */
    public boolean oldIsNew() {
        return oldIsnew;
    }

    /**
     * Returns true if the line in the listblock StudentCourses2List was
     * deleted last time reset was called. 
     * See documentation about state on class LineListblockStudentCourses2List.
     * @return True if it was changed, false if not.
     */
    public boolean oldIsChanged() {
        return oldIschanged;
    }

    /** The line number of this list block. Internal use only.
     * @return The line number in the listblock.
     */
    public int getLineNumber() {
        return lineNumber;
    }

    /** Internal use.
     * @param n Internal useage.
     */
    void setLineNumber(int n) {
        lineNumber = n;
    }

    /** Marks line as new and removes changed and deleted flags. 
     * See documentation about state on class LineListblockStudentCourses2List.
     */
    public void forceMarkAsNew() {
        ischanged = false;
        isnew = true;
        isdeleted = false;
    }

    /** Clears new, changed and deleted flags. 
     * See documentation about state on class LineListblockStudentCourses2List.
     */
    public void forceClean() {
        ischanged = false;
        isnew = false;
        isdeleted = false;
    }

    /** Marks line as new unless it already has been marked as
     * changed or deleted. 
     * See documentation about state on class LineListblockStudentCourses2List.
     */
    public void markAsNew() {
        if(ischanged || isdeleted) {
            return;
        }
        ischanged = false;
        isnew = true;
        isdeleted = false;
    }

    /** Marks the line as changed and clears new and deleted flags. 
     * See documentation about state on class LineListblockStudentCourses2List.
     */
    public void forceMarkAsChanged() {
        ischanged = true;
        isnew = false;
        isdeleted = false;
    }

    /** Marks line as changed unless it already has been marked as
     * new or deleted. 
     * See documentation about state on class LineListblockStudentCourses2List.
     */
    public void markAsChanged() {
        if(isdeleted || isnew) {
            return;
        }
        ischanged = true;
        isdeleted = false;
    }
    /** 
     * Copies state flags from the given listblock line to this
     * listblock line. Both old and new state are copied.
     * See documentation about state on class LineListblockStudentCourses2List.
     * @param src The listblockline to copy state flags from.
     */
    public void copyStateFlags(LineListblockStudentCourses2List src) {
        ischanged = src.ischanged;
        isnew = src.isnew;
        isdeleted = src.isdeleted;
        isdisabled = src.isdisabled;
        oldIschanged = src.oldIschanged;
        oldIsnew = src.oldIsnew;
        oldIsdeleted = src.oldIsdeleted;
    }

    /** Sets a listblock line as disabled/enabled for editing.
     * @param setting True hvis disabled.
     **/
    public void setDisabled(boolean setting) {
        isdisabled = setting;
    }
    /** Marks line as deleted. */
    public void markAsDeleted() {
        ischanged = false;
        isnew = false;
        isdeleted = true;
    }
    /** Marks line as deleted */
    public void forceMarkAsDeleted() {
        ischanged = false;
        isnew = false;
        isdeleted = true;
    }
    public boolean contains(Object domainObject) {
        return roleNameToObject.containsValue(domainObject);
    }

    public void setSelected(boolean select) {
        List currentSelection = new ArrayList();
        getListblock().clearEditFields();
        if (getListblock().getSelectedLinesObject() != null) {
            currentSelection.addAll(getListblock().getSelectedLinesObject());
        }
        if (!select) {
            currentSelection.remove(this);
        } else {
            currentSelection.add(this);
        }
        ListblockLine displayLine = select ? this : null;
        int[] selectedLines = new int[currentSelection.size()];
        if (currentSelection.size() > 0) {
            int lastSelectedLine = Integer.MAX_VALUE;
            for (int i = 0; i < currentSelection.size(); i++) {
                ListblockLine line = (ListblockLine) currentSelection.get(i);
                selectedLines[i] = line.getLineNumber();
                if (!select && line.getLineNumber() < lastSelectedLine) {
                    lastSelectedLine = line.getLineNumber();
                    displayLine = line;
                }
            }
        }
        getListblock().setSelectedLines(selectedLines);
        if (displayLine != null) {
            displayLine.displayInEditField();
        }
    }

    public boolean isSelected() {
        List selectedLines = getListblock().getSelectedLinesObject();
        return selectedLines != null ? selectedLines.contains(this) : false;
    }
         new = new ();
        /** Internal use. 
         * @param column Internal use.
         */
        void fromCellToListblockLine(int column) {
            DomainObjectProxy objectProxy = domainProxy.getProxy(new, "");
        }
    /** 
     * Internal use.
     * @param column Internal use.
     * @param defaultInsert Internal use.
     */
    void fromListblockLineToCell(int column, boolean defaultInsert) {
        // int correctedCol = ((Integer)controller.view.StudentCourses2List_indexes.elementAt(column)).intValue();
        }
        public void reset() {
            oldIschanged = ischanged;
            ischanged = false;
            oldIsnew = isnew;
            isnew = false;
            oldIsdeleted = isdeleted;
            isdeleted = false;
        }
        public void previousState() {
            controller.view.block.increaseListblockStudentCourses2List();
            boolean isDis = isdisabled;
            isdisabled = false;
            ischanged = oldIschanged;
            isnew = oldIsnew;
            isdeleted = oldIsdeleted;
            fromListblockLineToCells(false);
            controller.view.StudentCourses2ListtheModel.fireTableDataChanged();
            fromCellsToListblockLine();
            isdisabled = isDis;
            controller.view.block.decreaseListblockStudentCourses2List();
        }

    public Object obtain(String identifier) {
        if (identifier.indexOf(".") == -1) {
            return getDisplayedObject(identifier);
        } else {
            int colNumber = controller.listblockMethodsStudentCourses2List
                    .getColumnIndex(identifier);
            return controller.view.StudentCourses2List_table
                    .getValueAt(getLineNumber(), colNumber);
        }
    }

    public ListblockLine obtain() {
         return this;
    }               


    /**
     * Returns the <em>roleName</em> object held by this line.
     * If the object does not exist a new object is created. Invoking
     * this method has the same effect as invoking {@link #getObject(String, boolean)}.
     * @param roleName the role name of the object to return
     * @return the object held by this line.
     * @deprecated use {@link #getObject(String, boolean)} 
     */
    public Object getObject(String roleName) {
        if (controller.listblockMethodsStudentCourses2List
                .getRoleNamesInUse().contains(roleName)) {
            return getObject(roleName, true);
        } else {
            return roleNameToObject.get(roleName);
        }
    }


    public Object getObject(String roleName, boolean createIfNull) {
        Object o = roleNameToObject.get(roleName);
        if (o == null && createIfNull) {
            AbstractNode node = (AbstractNode) controller
                    .getObjectSelectionNode(roleName);
            if (node != null) {
                o = node.getEmptyDomainObject();
                roleNameToObject.put(roleName, o);
            }
        }
        return o;        
    }

    public void insertObject(String roleName, Object obj) {
        roleNameToObject.put(roleName, obj);
    }

    /**
     * Internal use. 
     * Sets the value for a specified column.
     */
    void setValueAt(int col, Object value) {
        switch (col) {
        }
    }
    private Object getDisplayedObject(String roleName) {
        return roleNameToObject.get(roleName);
    }
    public boolean hasPreviousState() {
       return true 
;
    }
    /** Edits cell in the given listblock line, where the object is
     *  'type' and column is 'fieldName'. The type object is not modified,
     *  and only used to decide which field is to be edited in the
     *  listblock. Valid type and fieldName combinations are:
     *  <ul>
     *  </ul>
     * @deprecated Use editFieldOS insted.
     * @param type The object selection to use
     * @param fieldName The field name to use.
     */    
    public void editField(Object type, String fieldName) {
        controller.view.block.increaseListblockStudentCourses2List();
        if(false) {
            /* Needed */
        }
            controller.view.block.decreaseListblockStudentCourses2List();
        }
    /** Edits cell in the given listblock line, where the object is
     *  'type' (the related object node) and column is 'fieldName'
     *  (named in Genova). The type object is not modified, and only
     *  used to decide which field is to be edited in the
     *  listblock. The valid combinations of type and fieldName are: *
     *  <ul>
     * </ul>
     * @param type The object selection node to use.
     * @param fieldName The fieldname to use.
     */
    public void editFieldOS(Object type, String fieldName) {
        controller.view.block.increaseListblockStudentCourses2List();
        if (false) {
            /* NEEDED */
        }
            controller.view.block.decreaseListblockStudentCourses2List();
        }
        /** Internal use */
        void fromCellsToListblockLine() {
            for(int i=0;i<controller.view.StudentCourses2List_table.getColumnCount();i++) {
                fromCellToListblockLine(i);
            }
        }
        public void refresh() {
            controller.view.block.increaseListblockStudentCourses2List();
            fromListblockLineToCells(false);
            int[] selected = controller.listblockMethodsStudentCourses2List.getSelectedLines();
            controller.view.StudentCourses2ListtheModel.fireTableDataChanged();
            controller.listblockMethodsStudentCourses2List.setSelectedLines(selected);
            controller.view.block.decreaseListblockStudentCourses2List();
        }
        /** Internal use. 
         *  @param defaultInsert internal use.
         */
        void fromListblockLineToCells(boolean defaultInsert) {
            for(int i= 0; i < controller.view
                    .StudentCourses2List_table.getColumnCount();i++) {
                fromListblockLineToCell(i, defaultInsert);
            }
        }

    public void displayInEditField() {
        new ClearTool(controller.roleObjects).clearMembers("");
        Iterator it = roleNameToObject.keySet().iterator();
        while (it.hasNext()) {
            String roleName = (String) it.next();
            ObjectSelectionNode node = controller.getObjectSelectionNode(roleName);
            Object clean = roleNameToObject.get(roleName);
            if (clean != null) {
                  node.display(getDisplayedObject(roleName));
            }
        }
    }

    public Collection getDomainObjects() {
        List objectList = new ArrayList();
        return objectList;
    }

    public int hashCode() {
        int hash = "StudentCourses2List".hashCode();

        return hash;
    }

    public boolean equals(Object o) {
        if (o == this) {
            return true; // base case
        }
        if (o == null || 
                !(o instanceof LineListblockStudentCourses2List)) {
            return false;
        }

        LineListblockStudentCourses2List line = 
            (LineListblockStudentCourses2List) o;

        return true;
    }
    public void addDomainObject(Object domainObject) {
    }
    public Listblock getListblock() {
        return controller.listblockMethodsStudentCourses2List;
    }
    public void setDisabledField(Object owner, String field, boolean setting) {
        if(owner == null) {
            throw new Error("No owner in setDisabledField.");
        }
        if(field == null || field.equals("")) {
            throw new Error("No name given to setDisabledField.");
        } 
        throw new Error("Class "+owner.getClass().toString()+" and field "+field+" isn't valid in setDisabledField for the listblock 'StudentCourses2List'\n");
    }
    /** Disables/enables a given field in the listblock line
     *  represented by the object selection node object owner. The
     *  field name is the field name given in Genova. Legal
     *  combinations of owner and field are: <ul>
        </ul>
     * @param owner The object selection to use
     * @param field The field name 
     * @param setting True if the field should be disabled, false if not.
     */
    public void setDisabledFieldOS(Object owner, String field, boolean setting) {
        if(owner == null) {
            throw new Error("No owner in setDisabledField.");
        }
        if(field == null || field.equals("")) {
            throw new Error("No name given to setDisabledField.");
        } 
        throw new Error("Class "+owner.getClass().toString()+" and field "+field+" isn't valid in setDisabledField for the listblock 'StudentCourses2List'\n");
    }
}  /* End of listblock line for StudentCourses2List */
