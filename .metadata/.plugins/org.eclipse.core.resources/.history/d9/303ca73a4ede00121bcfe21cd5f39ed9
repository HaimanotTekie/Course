// Generated with Genova.

package no.course.service.application.office.course_os.generated;

import no.course.domain.Assignment;
import no.course.domain.Answer;

import java.io.Serializable;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.List;
import java.util.LinkedList;
import java.util.Collection;
import java.util.Iterator;

import no.genova.dataaccess.Session;
import no.genova.jgrape.DataService;
import no.genova.jgrape.DataServiceImpl;
import no.genova.jgrape.Role;
import no.genova.jgrape.trigger.JGrapeTrigger.TriggerType;
import no.genova.jgrape.trigger.TriggerInvoker;
import no.genova.service.enumerator.ENavigation;
import no.genova.domain.DomainUtil;
import no.genova.support.ObjectSelection;
import no.genova.support.ClientContext;
import no.genova.support.FindData;
import no.genova.support.TypeTool;
import no.genova.support.ActionType;
import no.genova.exception.GenovaServiceException;
import no.genova.message.Message;
import no.genova.message.MessageFactory;
import no.genova.message.MessageSystem;
import no.genova.message.CRuntimeMsg;

/**
 * The <code>AnswersDefaultManager</code> class is generated by the Genova Service Generator from the object selection <code>Course_os</code>.
 * <p>
 * The java file containing this class should not be altered. All changes will be lost when the class is regenerated.
 * <p>
 * The class contains all methods used to manipulate the object selection role <code>answers</code>
 * <p>
 * The role answers data objects are of class <code>no.course.domain.Answer</code>;
 * <p>
 * <code>answers</code> is child role of the role <code>assignments</code> under the root role <code>Course</code>.
 * <br>
 * It is   member in the association between <code>assignments</code> and <code>answers</code>
 * <p>
 * The <code>answers</code> is a leaf role in the object selection <code>Course_os</code>
 * <p>
 * Object selection role documentation:
 * <br>
 * 
 * <p>
 * Class documentation:
 * <br>
 * 
 */
@SuppressWarnings("all")
abstract public class AnswersDefaultManager extends Role {

    /**
    * Contains the result after save/update/insert action. The parent object is the key object of this map
    */
    Map resultMap = new HashMap();


    /**
     * Hook method called at start of <code>cleanupResultAsTarget</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsTarget</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsTarget</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param rootResult The root node for the target node
     * @return true.
     */
    protected boolean hookCleanupResultAsTargetStart(Object rootResult) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsTarget</code> for role <code>answers</code>.
     *
     * @param resultObject The root node for the target node
     */
    protected void hookCleanupResultAsTargetEnd(Object resultObject) {
    }

    /**
     * Hook method called at start of <code>cleanupResultAsChild</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsChild</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsChild</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The <code>Assignment<code> object which is parent object in tghis cleanup
     * @return true.
     */
    protected boolean hookCleanupResultAsChildStart(Assignment parentObject) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsChild</code> for role <code>answers</code>.
     *
     * @param parentObject The <code>Assignment<code> object which is parent object in tghis cleanup
     */
    protected void hookCleanupResultAsChildEnd(Assignment parentObject) {
    }

    /**
     * Hook method called at start of <code>find</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the resulting object: <code>find</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>find</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>find</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Answer</code> object with the search data for the target.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookFindStart(ObjectSelection objectSelection,Answer targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>find</code> for <code>answers</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Answer</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindEnd(ObjectSelection objectSelection, Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the resulting object: <code>findSingle</code> will return the object found without futher actions.</li>
     *    <li>null: <code>findSingle</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Answer object with search data.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookFindSingleStart(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findSingle</code> will return null.</li>
     *    <li>true: <code>findSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param resultObject The <code>Answer</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true
     */
    protected boolean hookFindSingleEnd(Answer resultObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at start of <code>findAsRelated</code> for a <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findAsRelated</code> will return the result without futher actions.
     * The related <code>Answer</code> objects are expected to be connect to the <code>Assignment</code> parent object.</li>
     *    <li>true: <code>findAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The database <code>Assignment</code> object we want to find related <code>Answer</code> to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookFindAsRelatedStart(Assignment parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>findAsRelated</code> for a <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     *
     * @param parentObject The database <code>Assignment</code> object we want to find related <code>Answer</code> to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindAsRelatedEnd(Assignment parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findAll</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>List</code> with the resulting <code>Answer</code> objects: <code>findAll</code> will return the list to the client without futher actions.</li>
     *    <li>null: <code>findAll</code> will do its search for the wanted records.</li>
     *    <li>GenovaBaseException: findAll will be aborted.</li>
     * </ul>
     *
     * @param clazz The class of the target object of type <code>Answer</code>.
     * @param findData The search criteria. A null reference means using default search.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null
     */
    protected List hookFindAllStart(Class clazz, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findAll</code> for <code>answers</code>
     * <p>
     *
     * @param resultList The list of <code>Answer</code> objects found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     */
    protected void hookFindAllEnd(List resultList, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>save</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the resulting object: <code>save</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>save</code> will do its saving for the target object.</li>
     *    <li>GenovaBaseException: <code>save</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Answer</code> object with the data to be saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookSaveStart(ObjectSelection objectSelection, Answer targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>save</code> for <code>answers</code>.
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Answer</code> object that was saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveEnd(ObjectSelection objectSelection, Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the object saved: <code>saveSingle</code> will return the object saved without futher actions.</li>
     *    <li>null: <code>saveSingle</code> will do the saving of the target object.</li>
     *    <li>GenovaBaseException: <code>saveSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Answer object with data to be saved.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookSaveSingleStart(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>saveSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Answer</code> object saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveSingleEnd(Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveAsRelated</code> for a down related <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>saveAsRelated</code> will return without futher actions.
     * The related <code>Answer</code> objects are expected to be saved and connect to the <code>Assignment</code> database parent object.</li>
     *    <li>true: <code>saveAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>saveAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connect as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connect as it is in the database before the save.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookSaveAsRelatedStart(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>saveAsRelated</code> for a down related <code>Answer</code> object.
     * <p>
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connect as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connect as it is in the database after the save.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveAsRelatedEnd(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifySingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the object identified: <code>identifySingle</code> will return the object identified without futher actions.</li>
     *    <li>null: <code>identifySingle</code> will do identify of the target object.</li>
     *    <li>GenovaBaseException: <code>identifySingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The Answer object with data to be identified in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookIdentifySingleStart(Answer object, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>identifySingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Answer</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifySingleEnd(Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifyAsRelated</code> for a down related <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>identifyAsRelated</code> will return without futher actions.
     * The related <code>Answer</code> objects are expected to be identified and connected to the <code>Assignment</code> database parent object.</li>
     *    <li>true: <code>identifyAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>identifyAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as it is in the database befor the identify.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookIdentifyAsRelatedStart(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>identifyAsRelated</code> for a down related <code>Answer</code> object.
     * <p>
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as it is in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifyAsRelatedEnd(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifyAsRelated</code> for an up related <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>identifyAsRelated</code> will return without futher actions.
     * The up related <code>Answer</code> objects are expected to be identified and connected to the <code>Assignment</code> database parent object.</li>
     *    <li>true: <code>identifyAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>identifyAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookIdentifyAsRelatedStart(Assignment parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>identifyAsRelated</code> for an up related <code>Answer</code> object.
     * <p>
     *
     * @param parentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifyAsRelatedEnd(Assignment parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insert</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the resulting object: <code>insert</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>insert</code> will do its inserting for the target object.</li>
     *    <li>GenovaBaseException: <code>insert</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Answer</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookInsertStart(ObjectSelection objectSelection, Answer targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insert</code> for <code>answers</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Answer</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertEnd(ObjectSelection objectSelection, Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the object saved: <code>insertSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>insertSingle</code> will do the inserting of the target object.</li>
     *    <li>GenovaBaseException: <code>insertSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Answer object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookInsertSingleStart(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insertSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Answer</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertSingleEnd(Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertAsRelated</code> for a down related <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>insertAsRelated</code> will return without futher actions.
     * The related <code>Answer</code> objects are expected to be inserted and connected to the <code>Assignment</code> database parent object.</li>
     *    <li>true: <code>insertAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>insertAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as it is in the database befor the inserting.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookInsertAsRelatedStart(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>insertAsRelated</code> for a down related <code>Answer</code> object.
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as it is in the database after the inserting.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertAsRelatedEnd(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>update</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the resulting object: <code>update</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>update</code> will do its updating for the target object.</li>
     *    <li>GenovaBaseException: <code>update</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Answer</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookUpdateStart(ObjectSelection objectSelection, Answer targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>update</code> for <code>answers</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Answer</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateEnd(ObjectSelection objectSelection, Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Answer</code> with the object saved: <code>updateSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>updateSingle</code> will do the updating of the target object.</li>
     *    <li>GenovaBaseException: <code>updateSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Answer object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Answer hookUpdateSingleStart(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>updateSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Answer</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateSingleEnd(Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateAsRelated</code> for a down related <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>updateAsRelated</code> will return without futher actions.
     * The related <code>Answer</code> objects are expected to be updated and connected to the <code>Assignment</code> database parent object.</li>
     *    <li>true: <code>updateAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>updateAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as it is in the database befor the update.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookUpdateAsRelatedStart(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>updateAsRelated</code> for a down related <code>Answer</code> object.
     *
     * @param clientParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connected as it is in the database after the update.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateAsRelatedEnd(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>delete</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>delete</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>delete</code> will continue.</li>
     *    <li>GenovaBaseException: <code>delete</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Answer</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteStart(ObjectSelection objectSelection, Answer targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>delete</code> for <code>answers</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Answer</code> object that was deleted.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteEnd(ObjectSelection objectSelection, Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteSingle</code> will return without futher actions.</li>
     *    <li>true: <code>deleteSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The <code>Answer</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteSingleStart(Answer object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteSingle</code> for an object.
     * <p>
     *
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteSingleEnd(ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteAsRelated</code> for a related <code>Answer</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteAsRelated</code> will return without futher actions.
     * The related <code>Answer</code> objects are expected to be deleted or disconnect from the <code>Assignment</code> parent object.</li>
     *    <li>true: <code>deleteAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>Assignment</code> with the <code>Answer</code> objects connect as it is in the database before the delete.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteAsRelatedStart(Assignment parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteAsRelated</code> for a related <code>Answer</code> object.
     * <p>
     *
     * @param parentObject The parent object <code>Assignment</code> as it is in the database after the delete.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteAsRelatedEnd(Assignment parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>connect</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>connect</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>connect</code> will continue.</li>
     *    <li>GenovaBaseException: <code>connect</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Answer</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookConnectStart(ObjectSelection objectSelection, Answer targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>connect</code> for <code>answers</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Answer</code> object that was connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookConnectEnd(ObjectSelection objectSelection, Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>connectSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>connectSingle</code> will return without futher actions.</li>
     *    <li>true: <code>connectSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>connectSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param dbChildObject The <code>Answer</code> object to be connected.
     * @param dbParentObject The <code>Assignment</code> object to be connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookConnectSingleStart(Answer dbChildObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>connectSingle</code> for an object.
     * <p>
     *
     * @param dbChildObject The <code>Answer</code> object connected.
     * @param dbParentObject The <code>Assignment</code> object connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookConnectSingleEnd(Answer dbChildObject, Assignment dbParentObject,ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>disconnect</code> for role <code>answers</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>disconnect</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>disconnect</code> will continue.</li>
     *    <li>GenovaBaseException: <code>disconnect</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Answer</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDisconnectStart(ObjectSelection objectSelection, Answer targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>disconnect</code> for <code>answers</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Answer</code> object that was disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDisconnectEnd(ObjectSelection objectSelection, Answer resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>disconnectSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>disconnectSingle</code> will return without futher actions.</li>
     *    <li>true: <code>disconnectSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>disconnectSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param dbChildObject The <code>Answer</code> object to be disconnected.
     * @param dbParentObject The <code>Assignment</code> object to be disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDisconnectSingleStart(Answer dbChildObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>disconnectSingle</code> for an object.
     * <p>
     *
     * @param dbChildObject The <code>Answer</code> object disconnected.
     * @param dbParentObject The <code>Assignment</code> object disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDisconnectSingleEnd(Answer dbChildObject, Assignment dbParentObject,ClientContext ctx, Session session) {
    }

    /**
     * Hook method called from <code>initializeRole</code>. This hook may be used to override the key
     * definitions for the role.
     * <p>
     * When overriding this hook has two possible exits:
     * <ul>
     *    <li>false: Don't do the default initialization of class' keys<li>
     *    <li>true: Do the default initialization of the class' keys<li>
     * </ul>
     *
     * @return true.
     */
    protected boolean hookInitializeKeys() {
        return true;
    }

    /**
     * Initialize this role manager.
     * The method initializes super before own initialization.
     * 
     * @param applicationName Name of the application
     * @param name Name of the role.
     * @param parent Parent role manager. It should be a <code>AssignmentsDefaultManager</code>.
     */
    final public void initializeRole(String applicationName, String name, Role parent) {
        super.initializeRole(applicationName,name,parent);
        getIncludedAttributes().add("answerText");
        getIncludedAttributes().add("id");
        if (hookInitializeKeys()) {
            Key key;
            key = addKey("id",true,true);
            key.addAttribute("id");
        }
        resultMap.clear();
    }

    /**
     * Check if two <code>Answer<code> objects are identical.
     * They are identical if all attributes are equals() ( == for primitives) and
     * all uprelated points to the same objects
     *
     * @param firstObject The first <code>Answer</code> object.
     * @param secondObject The second <code>Answer</code> object.
     * @return true if the objects are identical
     */
    public boolean isIdentical(Answer firstObject, Answer secondObject) {
        boolean identical = true;
        if (firstObject != null && secondObject != null && firstObject != secondObject) {
           if (identical) {
               Object a1 = firstObject.getAnswerText();
               Object a2 = secondObject.getAnswerText();
               identical = (a1 != null) ? a1.equals(a2) : a2 == null;
           }
           if (identical) {
               identical = firstObject.getId() == secondObject.getId();
           }
        }
        else {
           identical = firstObject == secondObject;
        }
        return identical;
    }

    /**
     * Copy all attributes between two <code>Answer</code> objects.
     * The method copies the lock flag too, if the dbms implementation is with optimistic locking.
     *
     * @param fromObject The <code>Answer</code> object to copy from.
     * @param toObject The <code>Answer</code> object to copy to.
     * @param includedOnly true: Copy only attributes included in this object selection role.
     *                     false: Copy excludede attributes also.
     */
    final void copyAttributes(Answer fromObject, Answer toObject, boolean includedOnly) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
            toObject.setAnswerText(fromObject.getAnswerText());
            toObject.setId(fromObject.getId());
            DomainUtil.setLockFlag(toObject,DomainUtil.getLockFlag(fromObject));
        }
    }

    /**
     * Copy references to associated objects between two <code>Answer</code> objects.
     * The method copies the reference to the parent object if this role is a member role
     * of its parent and the association is navigable to the parent.
     * The method copies the reference to all child objects if this role is a member role
     * of its child. In this case the association will always be navigable to the child.
     *
     * @param fromObject The <code>Answer</code> object to copy from
     * @param toObject The <code>Answer</code> object to copy to
     */
    final void copyRelatedOwners(Answer fromObject, Answer toObject) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
        }
    }

    /**
     * Generate a new <code>Answer</code> object
     *
     * @return the new <code>Answer</code> object
     */
    final Answer newAnswer() {
        Answer object = new Answer();
        return object;
    }

    /**
     * Clone a <code>Answer</code> object. The method copies
     * attributes using <code>copyAttributes</code> and references to associated
     * objects using <code>copyRelatedOwners</code>. Other object references are
     * not copied.
     *
     * @param object The <code>Answer</code> object to clone
     * @return The new <code>Answer</code> object
     */
    final Answer cloneObject(Answer object) {
        Answer newObject = null;
        if (object != null) {
            newObject = newAnswer();
            copyAttributes(object,newObject,false);
            copyRelatedOwners(object,newObject);
        }
        return newObject;
    }

    /**
     * For this object selection role find the root roles data object in the
     * <code>ObjectSelection</code>.
     * If the root object is a Collection with more than one object, the first
     * object in the Collection is returned.
     *
     * @param objectSelection <code>ObjectSelection</code> to search for the root object
     * @return The <code>Course</code> object
     */
    final Object findRootObject(ObjectSelection objectSelection) {
        Object rootObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("answers")) {
                Collection roots = objectSelection.getRootObjects("answers");
                if (roots != null) {
                    Iterator iter = roots.iterator();
                    if (iter.hasNext()) {
                        rootObject = iter.next();
                    }
                }
            }
            else if (getParent() != null) {
                rootObject = ((AssignmentsDefaultManager)getParent()).findRootObject(objectSelection);
            }
        }
        return rootObject;
    }

    /**
     * Find target object in <code>ObjectSelection</code>.
     * The target object is either a domain object or a Collection of such objects.
     *
     * @param objectSelection The <code>ObjectSelection</code> to search.
     * @return Either a single target object or a <code>Collection</code> of target objects.
     */
    final Object findTargetObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("answers")) {
                resultObject = objectSelection.getRootObjects("answers");
                if (!(objectSelection.getTargetRoleName().equals("answers")) && resultObject != null) {
                    Iterator iter = ((Collection)resultObject).iterator();
                    resultObject = iter.hasNext() ? iter.next() : null;
                }
            }
            else if (getParent() != null) {
                Assignment parentObject = (Assignment)((AssignmentsDefaultManager)getParent()).findTargetObject(objectSelection);
                if (parentObject != null)
                {
                    resultObject = parentObject.getAnswers();
                    if (!(objectSelection.getTargetRoleName().equals("answers")) && resultObject != null) {
                        Iterator iter = ((Collection)resultObject).iterator();
                        resultObject = iter.hasNext() ? iter.next() : null;
                    }
                }
            }
        }
        return resultObject;
    }

    /**
     * Find parent object in an <code>ObjectSelection</code> for this role.
     * If the parent instance is inside a collection the method expects
     * this collection to contain one and only one occurence of the parent objects
     *
     * @param objectSelection The <code>ObjectSelection></code> to search
     * @return The parent <code>Assignment</code> object
     */
    final Assignment findParentObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null && getParent() != null) {
            String tmp = objectSelection.getTargetRoleName();
            objectSelection.setTargetRoleName("assignments");
            resultObject = ((AssignmentsDefaultManager)getParent()).findTargetObject(objectSelection);
            if (resultObject != null && (resultObject instanceof Collection)) {
                Iterator iter = ((Collection)resultObject).iterator();
                resultObject = iter.hasNext() ? (Assignment)(iter.next()) : null;
            }
            objectSelection.setTargetRoleName(tmp);
        }
        return (Assignment)resultObject;
    }

    /**
     * Check if a <code>Answer</code> object is child to a parent <code>Assignment</code> object.
     *
     * @param parentObject The parent <code>Assignment</code> 
     * @param childObject The child <code>Answer</code> 
     * @param session The <code>DataAccess</code> <code>Session</code>.
     *
     * @return true if childObject is a child of parentObject.
     */
    final boolean isChildPresent(Assignment parentObject,Answer childObject,Session session) {
        boolean present = false;
        DataService dataService = DataServiceImpl.getDataServiceImpl();
        dataService.findAssociated(parentObject.getAnswers(),session);
        Iterator iter = parentObject.getAnswers() != null ?
                            parentObject.getAnswers().iterator() :
                            null;
        while (iter != null && iter.hasNext() && !present) {
            if ((Answer)iter.next() == childObject) {
                present = true;
            }
        }
        return present;
    }

    /**
     * Make a connection from a parent <code>Assignment</code> to a child <code>Answer</code>.
     *
     * @param parentObject The <code>Assignment</code> who is owner in the association
     * @param childObject The <code>Answer</code> who is member in the association
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void connectFromParent(Assignment parentObject,Answer childObject,Session session) {
        if (parentObject != null && childObject != null && !isChildPresent(parentObject,childObject,session)) {
            parentObject.getAnswers().add(childObject);
        }
    }
    /**
     * Disconnect a child <code>Answer</code> from its parent <code>Assignment</code>.
     *
     * @param parentObject The <code>Assignment</code> who is owner in the association
     * @param childObject The <code>Answer</code> who is member in the association
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void disconnectFromParent(Assignment parentObject,Answer childObject,Session session) {
        if (parentObject != null && childObject != null && isChildPresent(parentObject,childObject,session)) {
            parentObject.getAnswers().remove(childObject);
        }
    }


    /**
     * Load all instances of this role
     *
     * @param dbParentObject
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void loadAll(Assignment dbParentObject,Session session) {
        if (dbParentObject != null) {
            Iterator iter;
            iter = dbParentObject.getAnswers() != null ?
                       dbParentObject.getAnswers().iterator() :
                       null;
        }
    }

    /**
     * Get current object from the result
     * This method is only when this role is above the target role, i.e. it assumes that there
     * is only one member in each collection from the root to this object
     *
     * @param rootResult The Object which is top node in the result
     */
    Answer getCurrentObject(Object rootResult) {
        Answer thisObject = null;
        if (getParent() != null) {
            Assignment parentObject = ((AssignmentsDefaultManager)getParent()).getCurrentObject(rootResult);
            if (parentObject != null) {
                Collection collection = parentObject.getAnswers();
                if (collection != null) {
                   Iterator iter = collection.iterator();
                   if (iter.hasNext()) thisObject = (Answer)(iter.next());
                }
            }
        }
        return thisObject;
    }

    /**
     * Do cleanup of result before sending it to the client. The cleanup will remove unneeded objects
     * to reduce the datatransfer between the server and the client.
     * This method is the entrypoint for cleanup after an insert/update/save with this role as target.
     * For each result root object in the result it will use cleanupAsTarget to remove unneeded objects.
     *
     * @param rootResult The Object who is the top of the path to target
     */
    public void cleanupResult(Object rootResult) {
        if (rootResult instanceof Collection) {
            Iterator iter = ((Collection)rootResult).iterator();
            while (iter.hasNext()) {
                cleanupResultAsTarget((Object)iter.next());
            }
        }
        else
        {
            cleanupResultAsTarget(rootResult);
        }
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for one result root object. For objects on the path to target it will remove
     * all downrelated children, but it will keep any uprelated children. For the target node itself it will
     * only keep those objects actually updated.
     *
     * @param rootResult The object which is the top of the path to target
     */
    public void cleanupResultAsTarget(Object rootResult) {
        if (hookCleanupResultAsTargetStart(rootResult)) {
            if (getParent() != null) {
                Answer thisObject = null;
                Assignment parentObject = ((AssignmentsDefaultManager)getParent()).cleanupResultAsParent(rootResult,"answers");
                if (parentObject != null) {
                    Collection children = (Collection)resultMap.get(parentObject);
                    if (children == null) {
                        children = TypeTool.getDefaultSet();
                    }
                    parentObject.setAnswers((Set)children);
                }
            }
        }
        hookCleanupResultAsTargetEnd(rootResult);
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for all related objects below the the target object in the object selction.
     *
     * @param parentObject The <code>Assignment</code> object who is parent to the objects processed. 
     */
    public void cleanupResultAsChild(Assignment parentObject) {
        if (hookCleanupResultAsChildStart(parentObject)) {
            if ((getCurrentObjectSelection().getDoFirstLevelManyRelated())) {
                getCurrentObjectSelection().setDoFirstLevelManyRelated(getCurrentObjectSelection().getDoAnyLevelManyRelated());
                if (parentObject != null) {
                    parentObject.setAnswers((Set)(resultMap.get(parentObject)));
                }
                getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
            } else {
                parentObject.setAnswers(null);
            }
        }
        hookCleanupResultAsChildEnd(parentObject);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and searches for a target object of class <code>Answer</code>.
     * <p>
     * Find is not an allowed action for role <code>answers</code>
     * <p>
     *
     * @param objectSelection The object selection with all search criteria.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object find(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object rootObject = null;
        List rootList = new LinkedList();
        Answer resultObject = null;
        Answer targetObject = null;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            if (iter.hasNext()) {
                targetObject = (Answer)iter.next();
            }
        }
        resultObject = hookFindStart(objectSelection,targetObject,ctx,session);
        if (resultObject == null) {
            Assignment parentObject = null;
            if (getParent() != null) {
                parentObject = findParentObject(objectSelection);
            }
            resultObject = findSingle(targetObject,objectSelection.getTargetMainKey(),objectSelection.getFindData(),ctx,session);
            if (parentObject != null) {
                if (targetObject != null) {
                    parentObject.getAnswers().remove(targetObject);
                }
                parentObject.getAnswers().add(resultObject);
            }
            if (getParent() == null) {
                if (resultObject != null) {
                    rootList.add(resultObject);
                }
            }
            else {
                rootObject = findRootObject(objectSelection);
                rootList.add(rootObject);
            }
            hookFindEnd(objectSelection,resultObject,ctx,session);
        }
        return rootList;
    }

    /**
     * Find a single <code>Answer</code> object in the database.
     * <p>
     * The method uses the search criteria defined in the <code>findData</code> parameter. Without any <code>findData</code>,
     * the method uses the targetKey to find the <code>Answer</code> object. The targetKey must be a unique attribute or group.
     * Without any targetKey the main key is chosen as the first unique key found where the all attributes are part of the
     * object selection. The unique keys are examined in the following sequence:
     * <ul>
     *     <li> The primary key
     *     <li> Attributes specified as unique
     *     <li> Groups specified as unique
     * </ul>
     *
     * @param targetObject The target <code>Answer</code> object with the key attributes.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object found.
     */
    public Answer findSingle(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Answer resultObject = hookFindSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            Class clazz = Answer.class;
            List keyAttributes = null;
            String primaryKey = getPrimaryKey();
            if (targetKey != null) {
                keyAttributes = getKeyAttributes(targetKey);
                if (primaryKey != null && !(primaryKey.equals(targetKey))) {
                    primaryKey = null;
                }
            }
            else {
                keyAttributes = getKeyAttributes(primaryKey != null ? primaryKey : getMainKey());
            }
            if (primaryKey == null && keyAttributes == null && findData == null) {
                Object[] args = { "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NO_KEY_DEFINED, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            if (findData != null || targetObject != null) {
                if (primaryKey != null) {
                    Serializable keyObject;
                    if (primaryKey.equals("id")) {

                        keyObject = targetObject != null ? (Serializable)TypeTool.toObject(targetObject.getId()) : null;
                        if (keyObject != null || findData != null) {
                            resultObject = (Answer)dataService.find(clazz,keyObject,findData,session);
                        }
                    }
                    else {
                        resultObject = (Answer)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                    }
                }
                else {
                    resultObject = (Answer)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                }
            }
        }
        if (!hookFindSingleEnd(resultObject,ctx,session)) {
            resultObject = null;
        }
        return resultObject;
    }

    /**
     * From a parent <code>Assignment</code> object find all related objects of the role <code>answers</code>.
     *
     * @param parentObject The <code>Assignment</code> object.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void findAsRelated(Assignment parentObject, ClientContext ctx, Session session) {
        if (hookFindAsRelatedStart(parentObject,ctx,session)) {
            if (parentObject != null) {
                DataService dataService = DataServiceImpl.getDataServiceImpl();
                dataService.findAssociated(parentObject.getAnswers(),session);
            }
        }
        hookFindAsRelatedEnd(parentObject,ctx,session);
    }
    /**
     * This method is part of the <code>Manager</code> Interface and finds all target objects of class <code>Answer</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will return all occurences of <code>Answer</code>. Each <code>Answer</code> object
     * returned will also contain all uprelated child objects. 
     *
     * @param objectSelection The object selection
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return List of <code>Answer</code> objects found.
     */
    public List<?> findAll(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        if (objectSelection.getFindData() != null && (objectSelection.getFindData().getDeepFindAll())) {
            objectSelection.setDoOneRelated(true);
            objectSelection.setDoFirstLevelManyRelated(true);
            objectSelection.setDoAnyLevelManyRelated(true);
        }
        List resultList = null;
        Class clazz = Answer.class;
        resultList = hookFindAllStart(clazz,objectSelection.getFindData(),ctx,session);
        if (resultList == null) {
            Answer targetObject = null;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                if (iter.hasNext()) {
                    targetObject = (Answer)iter.next();
                }
            }
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            resultList = dataService.findAll(clazz,targetObject,objectSelection.getFindData(),session);
        }
        hookFindAllEnd(resultList,ctx,session);
        return resultList;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and saves a target object of class <code>Answer</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object save(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Assignment clientParentObject = null;
        Assignment dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Assignment)findParentObject(objectSelection);
            if (clientParentObject != null)
            {
                dbParentObject = ((AssignmentsDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Assignment", "Answer", "Course_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Assignment", "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        Answer resultObject = null;
        Answer targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Answer)iter.next();
                ActionType action = ActionType.SAVE;
                if (objectSelection.getActions() != null) {
                    action = (ActionType)(objectSelection.getActions().get(targetObject));
                    if (action == null) action = ActionType.SAVE;
                }
                switch (action) {
                    case SAVE:
                        resultObject = save(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case INSERT:
                        resultObject = insert(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case UPDATE:
                        resultObject = update(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case DELETE:
                        delete(targetObject, clientParentObject, dbParentObject, ctx, session);
                        resultObject = null;
                        break;
                    case CONNECT:
                        if (getParent() != null) {
                            resultObject = connect(targetObject, clientParentObject, dbParentObject, ctx, session);
                        }
                        break;
                    case DISCONNECT:
                        if (getParent() != null) {
                            disconnect(targetObject, clientParentObject, dbParentObject, ctx, session);
                        }
                        resultObject = null;
                        break;
                    default:
                    {
                        Object[] args = { action.name() };
                        Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UNKNOWN_SERVICE_ACTION, args);
                        MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                        throw new GenovaServiceException(msg);
                    }
                }
                if (resultObject != null) {
                    if (getParent() == null) {
                        rootList.add(resultObject);
                    } else {
                        resultSet.add(resultObject);
                    }
                }
            }
        }
        if (getParent() != null) {
            if (objectSelection.getActions() == null && objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Save one <code>Answer</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the database.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param clientParentObject The <code>Assignment</code> object as sent from the client.
     * @param dbParentObject The <code>Assignment</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object as updated/inserted into the database.
     */
    public Answer save(Answer targetObject, Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Answer resultObject;
        resultObject = hookSaveStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = saveSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultObject,session);
                }
            }
        }
        hookSaveEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Save a single <code>Answer</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the databse.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object as updated/inserted into the database.
     */
    public Answer saveSingle(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Answer resultObject = null;
        resultObject = hookSaveSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                resultObject = updateSingle(targetObject,targetKey,findData,ctx,session);
            }
            else {
                resultObject = insertSingle(targetObject,targetKey,findData,ctx,session);
            }
        }
        hookSaveSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>Assignment</code> object save all related <code>Answer</code> objects.
     * <p>
     * The method will try to insert occurences from the client object not present in the database object,
     * update occurences present in both the client object and the database object and it will try to delete
     * object present in the database object but not present in the client object.
     *
     * @param clientParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as recieved from the client.
     * @param dbParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void saveAsRelated(Assignment clientParentObject, Assignment dbParentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        if (hookSaveAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            Answer childObject;
            Answer resultChildObject;
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getAnswers() != null ?
                                clientParentObject.getAnswers().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (Answer)iter.next();
                resultChildObject = saveSingle(childObject,null,null,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookSaveAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * Identify a single <code>Answer</code> object in the database.
     * <p>
     * If the target object does not exist in the database an exception in thrown.
     *
     * @param object The <code>Answer</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object as it is in the database.
     */
    public Answer identifySingle(Answer object,ClientContext ctx,Session session)
    {
        Answer resultObject = hookIdentifySingleStart(object,ctx,session);
        if (resultObject == null) {
            resultObject = (Answer)cloneObject(object);
            resultObject = findSingle(resultObject,null,null,ctx,session);
            if (resultObject == null) {
                Object[] args = { "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_IDENTIFY_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookIdentifySingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>Assignment</code> object identify all related <code>Answer</code> objects.
     * <p>
     * The method will try to identify all occurences present in the client object 
     * and it will try to delete objects present in the database object but not present in the client object.
     * An exception in thrown if an object in the client object is not present in the database object.
     *
     * @param clientParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as recieved from the client.
     * @param dbParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void identifyAsRelated(Assignment clientParentObject, Assignment dbParentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        Answer childObject;
        Answer resultChildObject;
        if (hookIdentifyAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getAnswers() != null ?
                                clientParentObject.getAnswers().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (Answer)iter.next();
                resultChildObject = identifySingle(childObject,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookIdentifyAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and inserts a target object of class <code>Answer</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object insert(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Assignment clientParentObject = null;
        Assignment dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Assignment)findParentObject(objectSelection);
            if (clientParentObject != null)
            {
                dbParentObject = ((AssignmentsDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Assignment", "Answer", "Course_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Assignment", "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        Answer resultObject = null;
        Answer targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Answer)iter.next();
                resultObject = insert(targetObject, clientParentObject, dbParentObject, ctx, session);
                if (getParent() == null) {
                    rootList.add(resultObject);
                } else {
                    resultSet.add(resultObject);
                }
            }
        }
        if (getParent() != null) {
            if (objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Insert one <code>Answer</code> object and its related objects.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param clientParentObject The <code>Assignment</code> object as sent from the client.
     * @param dbParentObject The <code>Assignment</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object as inserted into the database.
     */
    Answer insert(Answer targetObject, Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Answer resultObject;
        resultObject = hookInsertStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = insertSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultObject,session);
                }
            }
        }
        hookInsertEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Insert a single <code>Answer</code> object into the database.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object as updated into the database.
     */
    public Answer insertSingle(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Answer resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
        if (!isIdentical(targetObject,resultObject)) {
            Answer tmpObject = hookInsertSingleStart(targetObject,targetKey,findData,ctx,session);
            if (tmpObject == null) {
                if (resultObject == null) {
                    resultObject = cloneObject(targetObject);
                    DomainUtil.setLockFlag(resultObject,null);
                    DataService dataService = DataServiceImpl.getDataServiceImpl();
                    dataService.insert(resultObject,session); 
                }
                else {
                    Object[] args = { "Answer", "Course_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_INSERT_ON_EXISTING, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
            }
            else {
              resultObject = tmpObject;
            }
            TriggerInvoker.invoke(resultObject,TriggerType.INSERT, getCurrentObjectSelection().getTargetRoleName().equals("answers"), ctx, session);
            hookInsertSingleEnd(resultObject,ctx,session);
        }
        return resultObject;
    }

    /**
     * From a <code>Assignment</code> object insert all related <code>Answer</code> objects.
     * <p>
     * The method will try to insert occurences present in the client object
     * and it will try to delete objects present in the database object but not present in the client object.
     * An exception in thrown if an object in the client object is present in the database object.
     *
     * @param clientParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as recieved from the client.
     * @param dbParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void insertAsRelated(Assignment clientParentObject, Assignment dbParentObject, boolean setsContainAllRelated,ClientContext ctx, Session session) {
        if (hookInsertAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            Answer childObject;
            Answer resultChildObject;
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getAnswers() != null ?
                                clientParentObject.getAnswers().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (Answer)iter.next();
                resultChildObject = insertSingle(childObject,null,null,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookInsertAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and updates a target object of class <code>Answer</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object update(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Assignment clientParentObject = null;
        Assignment dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Assignment)findParentObject(objectSelection);
            if (clientParentObject != null)
            {
                dbParentObject = ((AssignmentsDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Assignment", "Answer", "Course_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Assignment", "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        Answer resultObject = null;
        Answer targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Answer)iter.next();
                resultObject = update(targetObject, clientParentObject, dbParentObject, ctx, session);
                if (getParent() == null) {
                    rootList.add(resultObject);
                } else {
                    resultSet.add(resultObject);
                }
            }
        }
        if (getParent() != null) {
            if (objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Update one <code>Answer</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param clientParentObject The <code>Assignment</code> object as sent from the client.
     * @param dbParentObject The <code>Assignment</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object as updated in the database.
     */
    Answer update(Answer targetObject, Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Answer resultObject;
        resultObject = hookUpdateStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = updateSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultObject,session);
                }
            }
        }
        hookUpdateEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }


    /**
     * Update a single <code>Answer</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Answer</code> object as updated into the database.
     */
    public Answer updateSingle(Answer targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Answer resultObject = null;
        resultObject = hookUpdateSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                if (!isIdentical(targetObject,resultObject)) {
                    if (DomainUtil.hasLockFlag(resultObject)) {
                        Serializable targetFlag = DomainUtil.getLockFlag(targetObject);
                        Serializable resultFlag = DomainUtil.getLockFlag(resultObject);
                        if (targetFlag == null || (!(DomainUtil.equalsLockFlag(targetFlag,resultFlag)))) {
                            Object[] args = { "Answer" };
                            Message msg = MessageSystem.getMessageFactory().getMessage(targetFlag == null ? CRuntimeMsg.SM_NO_LOCKFLAG_VALUE : CRuntimeMsg.SM_UPDATED_BY_ANOTHER_USER, args);
                            MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                            throw new GenovaServiceException(msg);
                        }
                   }
                   copyAttributes(targetObject,resultObject,true);
                   copyRelatedOwners(targetObject,resultObject);
                }
                TriggerInvoker.invoke(resultObject,TriggerType.UPDATE, getCurrentObjectSelection().getTargetRoleName().equals("answers"), ctx, session);
            }
            else {
                Object[] args = { "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UPDATE_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookUpdateSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>Assignment</code> object update all related <code>Answer</code> objects.
     * <p>
     * The method will try to update occurences present in both the client object and the database object
     * and it will try to delete object present in the database object but not present in the client object.
     * An exception in thrown if an object in the client object is not present in the database object.
     *
     * @param clientParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as recieved from the client.
     * @param dbParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void updateAsRelated(Assignment clientParentObject, Assignment dbParentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        Answer childObject;
        Answer resultChildObject;
        if (hookUpdateAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getAnswers() != null ?
                                clientParentObject.getAnswers().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (Answer)iter.next();
                resultChildObject = updateSingle(childObject,null,null,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookUpdateAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and deletes a target object of class <code>Answer</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object delete(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Assignment clientParentObject = null;
        Assignment dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Assignment)findParentObject(objectSelection);
            dbParentObject = null;
            if (clientParentObject != null)
            {
                dbParentObject = ((AssignmentsDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Assignment", "Answer", "Course_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Assignment", "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        Answer targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Answer)iter.next();
                delete(targetObject,clientParentObject,dbParentObject,ctx,session);
            }
        }
        if (getParent() != null) {
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Delete a single <code>Answer</code> object and all it's related objects in the database.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param clientParentObject The <code>Assignment</code> object as sent from the client.
     * @param dbParentObject The <code>Assignment</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void delete(Answer targetObject,Assignment clientParentObject,Assignment dbParentObject,ClientContext ctx,Session session) {
        Answer resultObject = null;
        if (hookDeleteStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            deleteSingle(resultObject,ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    loadAll(dbParentObject,session);
                    dbParentObject.getAnswers().remove(resultObject);
                }
            }
        }
        hookDeleteEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Delete a single <code>Answer</code> object in the database.
     *
     * @param object The <code>Answer</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteSingle(Answer object,ClientContext ctx,Session session) {
        if (hookDeleteSingleStart(object,ctx,session)) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            dataService.delete(object,session);
            TriggerInvoker.invoke(object,TriggerType.DELETE, getCurrentObjectSelection().getTargetRoleName().equals("answers"), ctx, session);
        }
        hookDeleteSingleEnd(ctx,session);
    }

    /**
     * From a <code>Assignment</code> object delete all related <code>Answer</code> objects.
     * This role is a member in the association to the parent.
     *
     * @param parentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as it is in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteAsRelated(Assignment parentObject, ClientContext ctx, Session session) {
        Answer childObject;
        if (hookDeleteAsRelatedStart(parentObject,ctx,session)) {
            if (parentObject != null) {
                Iterator iter = parentObject.getAnswers() != null ? 
                                parentObject.getAnswers().iterator() :
                                null;
                while (iter != null && iter.hasNext()) {
                    childObject = (Answer)iter.next();
                    deleteSingle(childObject,ctx,session);
                    session.flush();
                    iter.remove();
                }
            }
        }
        hookDeleteAsRelatedEnd(parentObject,ctx,session);
    }

    /**
     * From a <code>Assignment</code> object delete related <code>Answer</code> objects that is present in the database but not in the client.
     *
     * @param clientParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as it is recived from the client
     * @param dbParentObject The <code>Assignment</code> object with it's child <code>Answer</code> objects as it is in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteAsRelated(Assignment clientParentObject, Assignment dbParentObject, ClientContext ctx, Session session) {
        if (clientParentObject != null && dbParentObject != null) {
            Iterator iterDb = dbParentObject.getAnswers() != null ?
                                  dbParentObject.getAnswers().iterator() :
                                  null;
            Answer dbChildObject;
            while (iterDb != null && iterDb.hasNext()) {
              boolean found = false;
              dbChildObject = (Answer)(iterDb.next());
              Iterator iterClient = clientParentObject.getAnswers() != null ?
                                        clientParentObject.getAnswers().iterator() :
                                        null;
              while (iterClient != null && iterClient.hasNext()) {
                  if (dbChildObject.equals(iterClient.next())) {
                      found = true;
                      break;
                  }
              }
              if (!found) {
                deleteSingle(dbChildObject,ctx,session);
                iterDb.remove();
            }
          }
        }
    }

    /**
     * This method is part of the <code>Manager</code> Interface and connects a target object of class <code>Answer</code> to its parent node <code>Assignment.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object connect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Assignment clientParentObject = null;
        Assignment dbParentObject = null;
        List rootList = new LinkedList();
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Assignment)findParentObject(objectSelection);
            dbParentObject = null;
            if (clientParentObject != null)
            {
                dbParentObject = ((AssignmentsDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Assignment", "Answer", "Course_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Assignment", "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            Answer targetObject;
            Answer resultObject;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                while (iter.hasNext()) {
                    targetObject = (Answer)iter.next();
                    resultObject = connect(targetObject,clientParentObject,dbParentObject,ctx,session);
                    resultSet.add(resultObject);
                }
            }
            if (objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Connect a single <code>Answer</code> object to its parent <code>Assignment object.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param clientParentObject The <code>Assignment</code> object as sent from the client.
     * @param dbParentObject The <code>Assignment</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public Answer connect(Answer targetObject,Assignment clientParentObject,Assignment dbParentObject,ClientContext ctx,Session session) {
        Answer resultObject = null;
        if (hookConnectStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            connectSingle(resultObject,dbParentObject,ctx,session);
        }
        hookConnectEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Connect a single <code>Answer</code> object from its parent Assignment in the database.
     *
     * @param dbChildObject The <code>Answer</code> object as found in the database
     * @param dbParentObject The <code>Assignment</code> object as found in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void connectSingle(Answer dbChildObject,Assignment dbParentObject,ClientContext ctx,Session session) {
        if (hookConnectSingleStart(dbChildObject,dbParentObject,ctx,session)) {
            if (dbParentObject != null && dbChildObject != null) {
                dbParentObject.getAnswers().add(dbChildObject);
            }
        }
        hookConnectSingleEnd(dbChildObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and disconnects a target object of class <code>Answer</code> from its parent node <code>Assignment.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object disconnect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Assignment clientParentObject = null;
        Assignment dbParentObject = null;
        List rootList = new LinkedList();
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Assignment)findParentObject(objectSelection);
            dbParentObject = null;
            if (clientParentObject != null)
            {
                dbParentObject = ((AssignmentsDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Assignment", "Answer", "Course_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Assignment", "Answer", "Course_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            Answer targetObject;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                while (iter.hasNext()) {
                    targetObject = (Answer)iter.next();
                    disconnect(targetObject,clientParentObject,dbParentObject,ctx,session);
                }
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Disconnect a single <code>Answer</code> object from its parent <code>Assignment object.
     *
     * @param targetObject The <code>Answer</code> object as sent from the client.
     * @param clientParentObject The <code>Assignment</code> object as sent from the client.
     * @param dbParentObject The <code>Assignment</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void disconnect(Answer targetObject,Assignment clientParentObject,Assignment dbParentObject,ClientContext ctx,Session session) {
        Answer resultObject = null;
        if (hookDisconnectStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            disconnectSingle(resultObject,dbParentObject,ctx,session);
        }
        hookDisconnectEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Disconnect a single <code>Answer</code> object from its parent Assignment in the database.
     *
     * @param dbChildObject The <code>Answer</code> object as found in the database
     * @param dbParentObject The <code>Assignment</code> object as found in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void disconnectSingle(Answer dbChildObject,Assignment dbParentObject,ClientContext ctx,Session session) {
        if (hookDisconnectSingleStart(dbChildObject,dbParentObject,ctx,session)) {
            if (dbParentObject != null && dbChildObject != null) {
                dbParentObject.getAnswers().remove(dbChildObject);
            }
        }
        hookDisconnectSingleEnd(dbChildObject,dbParentObject,ctx,session);
    }
   
    /**
     * This method is part of the <code>Manager</code> Interface and gets the target <code>Answer</code> object the database.
     *
     * @param objectSelection The <code>ObjectSelection</code> containing the data from the client.
     * @param navigation
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return Object
     */
    public Object get(ObjectSelection objectSelection, ENavigation navigation, ClientContext ctx, Session session) {
        return null;
    }
}
