// Generated with Genova.

package no.course.service.application.office.addstudentstocourse_os.generated;

import no.course.domain.Course;
import no.course.domain.StudentCourse;
import no.course.service.application.office.addstudentstocourse_os.AddStudentsToCourse_osOsManager;

import java.io.Serializable;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.List;
import java.util.LinkedList;
import java.util.Collection;
import java.util.Iterator;

import no.genova.dataaccess.Session;
import no.genova.jgrape.DataService;
import no.genova.jgrape.DataServiceImpl;
import no.genova.jgrape.Role;
import no.genova.jgrape.trigger.JGrapeTrigger.TriggerType;
import no.genova.jgrape.trigger.TriggerInvoker;
import no.genova.service.enumerator.ENavigation;
import no.genova.domain.DomainUtil;
import no.genova.support.ObjectSelection;
import no.genova.support.ClientContext;
import no.genova.support.FindData;
import no.genova.support.TypeTool;
import no.genova.support.ActionType;
import no.genova.exception.GenovaServiceException;
import no.genova.message.Message;
import no.genova.message.MessageFactory;
import no.genova.message.MessageSystem;
import no.genova.message.CRuntimeMsg;

/**
 * The <code>CourseDefaultManager</code> class is generated by the Genova Service Generator from the object selection <code>AddStudentsToCourse_os</code>.
 * <p>
 * The java file containing this class should not be altered. All changes will be lost when the class is regenerated.
 * <p>
 * The class contains all methods used to manipulate the object selection role <code>Course</code>
 * <p>
 * The role Course data objects are of class <code>no.course.domain.Course</code>;
 * <p>
 * <code>Course</code> is a root role.
 * <p>
 * Child roles to <code>Course</code>:
 * <ul>
 * <li><code>studentCourses</code></li>
 * </ul>
 * <p>
 * Object selection role documentation:
 * <br>
 * 
 * <p>
 * Class documentation:
 * <br>
 * 
 */
@SuppressWarnings("all")
abstract public class CourseDefaultManager extends Role {

    /**
    * Contains the result after save/update/insert action. The parent object is the key object of this map
    */
    Map resultMap = new HashMap();


    /**
     * Hook method called at start of <code>cleanupResultAsTarget</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsTarget</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsTarget</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param rootResult The root node for the target node
     * @return true.
     */
    protected boolean hookCleanupResultAsTargetStart(Object rootResult) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsTarget</code> for role <code>Course</code>.
     *
     * @param resultObject The root node for the target node
     */
    protected void hookCleanupResultAsTargetEnd(Object resultObject) {
    }

    /**
     * Hook method called at start of <code>cleanupResultAsParent</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with object. <code>cleanupResultAsParent</code> will return the result without futher actions.</li>
     *    <li>null: <code>cleanupResultAsParent</code> will do the cleanup.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param rootResult The Object which is the top of the path to target
     * @param childRoleName The name of the child role calling this method
     * @return null.
     */
    protected Course hookCleanupResultAsParentStart(Object rootResult,String childRoleName) {
        return null;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsParent</code> for role <code>Course</code>.
     *
     * @param resultObject The Object which is the target for the cleanup
     * @param childRoleName The name of the child role calling this method
     */
    protected void hookCleanupResultAsParentEnd(Course resultObject,String childRoleName) {
    }

    /**
     * Hook method called at start of <code>find</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the resulting object: <code>find</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>find</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>find</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Course</code> object with the search data for the target.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookFindStart(ObjectSelection objectSelection,Course targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>find</code> for <code>Course</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Course</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindEnd(ObjectSelection objectSelection, Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the resulting object: <code>findSingle</code> will return the object found without futher actions.</li>
     *    <li>null: <code>findSingle</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Course object with search data.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookFindSingleStart(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findSingle</code> will return null.</li>
     *    <li>true: <code>findSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param resultObject The <code>Course</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true
     */
    protected boolean hookFindSingleEnd(Course resultObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at start of <code>findDownRelated</code> for a <code>Course</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findDownRelated</code> will return the result without futher actions.
     * The related objects is expected to be connect to the <code>Course</code> object.</li>
     *    <li>true: <code>findDownRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findDownRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param object The database <code>Course</code> object we want to find all down related objects to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookFindDownRelatedStart(Course object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>findDownRelated</code> for a <code>Course</code> object.
     * <p>
     *
     * @param object The database <code>Course</code> object we want to find all down related objects to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindDownRelatedEnd(Course object, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findAll</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>List</code> with the resulting <code>Course</code> objects: <code>findAll</code> will return the list to the client without futher actions.</li>
     *    <li>null: <code>findAll</code> will do its search for the wanted records.</li>
     *    <li>GenovaBaseException: findAll will be aborted.</li>
     * </ul>
     *
     * @param clazz The class of the target object of type <code>Course</code>.
     * @param findData The search criteria. A null reference means using default search.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null
     */
    protected List hookFindAllStart(Class clazz, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findAll</code> for <code>Course</code>
     * <p>
     *
     * @param resultList The list of <code>Course</code> objects found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     */
    protected void hookFindAllEnd(List resultList, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>save</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the resulting object: <code>save</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>save</code> will do its saving for the target object.</li>
     *    <li>GenovaBaseException: <code>save</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Course</code> object with the data to be saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookSaveStart(ObjectSelection objectSelection, Course targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>save</code> for <code>Course</code>.
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Course</code> object that was saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveEnd(ObjectSelection objectSelection, Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the object saved: <code>saveSingle</code> will return the object saved without futher actions.</li>
     *    <li>null: <code>saveSingle</code> will do the saving of the target object.</li>
     *    <li>GenovaBaseException: <code>saveSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Course object with data to be saved.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookSaveSingleStart(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>saveSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Course</code> object saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveSingleEnd(Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveDownRelated</code> for a <code>Course</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>saveDownRelated</code> will return the result without futher actions.
     * The related objects is expected to be connect to the <code>Course</code> object.</li>
     *    <li>true: <code>saveDownRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>saveDownRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientObject The object <code>Course</code> as sent from the client.
     * @param dbObject The object <code>Course</code> as it is in the database before saveDownRelated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookSaveDownRelatedStart(Course clientObject, Course dbObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>saveDownRelated</code> for a <code>Course</code> object.
     * <p>
     *
     * @param clientObject The object <code>Course</code> as sent from the client.
     * @param dbObject The object <code>Course</code> as it is in the database after saveDownRelated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveDownRelatedEnd(Course clientObject, Course dbObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveAsParent</code> for a <code>Course</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the object saved: <code>saveAsParent</code> will return the object identified  without futher actions.</li>
     *    <li>null: <code>saveAsParent</code> will do the saving of the target object.</li>
     *    <li>GenovaBaseException: <code>saveAsParent</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param object The Course object with data to be identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookSaveAsParentStart(ObjectSelection objectSelection,Course object,ClientContext ctx,Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>saveAsParent</code> for a <code>Course</code> object.
     * <p>
     *
     * @param resultObject The <code>Course</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveAsParentEnd(Course resultObject,ClientContext ctx,Session session) {
    }

    /**
     * Hook method called at start of <code>identifySingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the object identified: <code>identifySingle</code> will return the object identified without futher actions.</li>
     *    <li>null: <code>identifySingle</code> will do identify of the target object.</li>
     *    <li>GenovaBaseException: <code>identifySingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The Course object with data to be identified in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookIdentifySingleStart(Course object, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>identifySingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Course</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifySingleEnd(Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insert</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the resulting object: <code>insert</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>insert</code> will do its inserting for the target object.</li>
     *    <li>GenovaBaseException: <code>insert</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Course</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookInsertStart(ObjectSelection objectSelection, Course targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insert</code> for <code>Course</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Course</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertEnd(ObjectSelection objectSelection, Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the object saved: <code>insertSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>insertSingle</code> will do the inserting of the target object.</li>
     *    <li>GenovaBaseException: <code>insertSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Course object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookInsertSingleStart(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insertSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Course</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertSingleEnd(Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>update</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the resulting object: <code>update</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>update</code> will do its updating for the target object.</li>
     *    <li>GenovaBaseException: <code>update</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Course</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookUpdateStart(ObjectSelection objectSelection, Course targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>update</code> for <code>Course</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Course</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateEnd(ObjectSelection objectSelection, Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Course</code> with the object saved: <code>updateSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>updateSingle</code> will do the updating of the target object.</li>
     *    <li>GenovaBaseException: <code>updateSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Course object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Course hookUpdateSingleStart(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>updateSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Course</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateSingleEnd(Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>delete</code> for role <code>Course</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>delete</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>delete</code> will continue.</li>
     *    <li>GenovaBaseException: <code>delete</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Course</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteStart(ObjectSelection objectSelection, Course targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>delete</code> for <code>Course</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Course</code> object that was deleted.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteEnd(ObjectSelection objectSelection, Course resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteSingle</code> will return without futher actions.</li>
     *    <li>true: <code>deleteSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The <code>Course</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteSingleStart(Course object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteSingle</code> for an object.
     * <p>
     *
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteSingleEnd(ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteRelated</code> for a <code>Course</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteRelated</code> will return without futher actions.
     * The related objects is expected to be delete or disonnect to the <code>Course</code> object.</li>
     *    <li>true: <code>deleteRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param object The database <code>Course</code> object we want to delete all related objects to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteRelatedStart(Course object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteRelated</code> for a <code>Course</code> object.
     * <p>
     *
     * @param object The database <code>Course</code> object we have deleted all related nodes to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteRelatedEnd(Course object, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called from <code>initializeRole</code>. This hook may be used to override the key
     * definitions for the role.
     * <p>
     * When overriding this hook has two possible exits:
     * <ul>
     *    <li>false: Don't do the default initialization of class' keys<li>
     *    <li>true: Do the default initialization of the class' keys<li>
     * </ul>
     *
     * @return true.
     */
    protected boolean hookInitializeKeys() {
        return true;
    }

    /**
     * Initialize this role manager.
     * The method initializes super before own initialization.
     * 
     * @param applicationName Name of the application
     * @param name Name of the role.
     * @param parent Parent role manager. It should be null.
     */
    final public void initializeRole(String applicationName, String name, Role parent) {
        Role role;
        super.initializeRole(applicationName,name,parent);
        getIncludedAttributes().add("code");
        getIncludedAttributes().add("id");
        getIncludedAttributes().add("isActive");
        getIncludedAttributes().add("name");
        if (hookInitializeKeys()) {
            Key key;
            key = addKey("code",true,false);
            key.addAttribute("code");
            key = addKey("id",true,true);
            key.addAttribute("id");
        }
        role = AddStudentsToCourse_osOsManager.newRoleManager(applicationName,"studentCourses");
        if (role != null) {
            role.initializeRole(applicationName, "studentCourses",this);
            getDownRelated().add(role);
        }
        resultMap.clear();
    }

    /**
     * Set the currentObjectSelectionProperty
     * 
     * @param objectSelection New current ObjectSelection
     */
    final public void setCurrentObjectSelection(ObjectSelection objectSelection) {
        super.setCurrentObjectSelection(objectSelection);
        Role role;
        role = findRole("studentCourses");
        if (role != null) {
            role.setCurrentObjectSelection(objectSelection);
        }
    }

    /**
     * Check if two <code>Course<code> objects are identical.
     * They are identical if all attributes are equals() ( == for primitives) and
     * all uprelated points to the same objects
     *
     * @param firstObject The first <code>Course</code> object.
     * @param secondObject The second <code>Course</code> object.
     * @return true if the objects are identical
     */
    public boolean isIdentical(Course firstObject, Course secondObject) {
        boolean identical = true;
        if (firstObject != null && secondObject != null && firstObject != secondObject) {
           if (identical) {
               Object a1 = firstObject.getCode();
               Object a2 = secondObject.getCode();
               identical = (a1 != null) ? a1.equals(a2) : a2 == null;
           }
           if (identical) {
               identical = firstObject.getId() == secondObject.getId();
           }
           if (identical) {
               identical = firstObject.getIsActive() == secondObject.getIsActive();
           }
           if (identical) {
               Object a1 = firstObject.getName();
               Object a2 = secondObject.getName();
               identical = (a1 != null) ? a1.equals(a2) : a2 == null;
           }
        }
        else {
           identical = firstObject == secondObject;
        }
        return identical;
    }

    /**
     * Copy all attributes between two <code>Course</code> objects.
     * The method copies the lock flag too, if the dbms implementation is with optimistic locking.
     *
     * @param fromObject The <code>Course</code> object to copy from.
     * @param toObject The <code>Course</code> object to copy to.
     * @param includedOnly true: Copy only attributes included in this object selection role.
     *                     false: Copy excludede attributes also.
     */
    final void copyAttributes(Course fromObject, Course toObject, boolean includedOnly) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
            toObject.setCode(fromObject.getCode());
            toObject.setId(fromObject.getId());
            toObject.setIsActive(fromObject.getIsActive());
            toObject.setName(fromObject.getName());
            DomainUtil.setLockFlag(toObject,DomainUtil.getLockFlag(fromObject));
        }
    }

    /**
     * Copy references to associated objects between two <code>Course</code> objects.
     * The method copies the reference to the parent object if this role is a member role
     * of its parent and the association is navigable to the parent.
     * The method copies the reference to all child objects if this role is a member role
     * of its child. In this case the association will always be navigable to the child.
     *
     * @param fromObject The <code>Course</code> object to copy from
     * @param toObject The <code>Course</code> object to copy to
     */
    final void copyRelatedOwners(Course fromObject, Course toObject) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
        }
    }

    /**
     * Generate a new <code>Course</code> object
     *
     * @return the new <code>Course</code> object
     */
    final Course newCourse() {
        Course object = new Course();
        Set<StudentCourse> studentCoursesSet = TypeTool.getDefaultSet();
        object.setStudentCourses(studentCoursesSet);
        return object;
    }

    /**
     * Clone a <code>Course</code> object. The method copies
     * attributes using <code>copyAttributes</code> and references to associated
     * objects using <code>copyRelatedOwners</code>. Other object references are
     * not copied.
     *
     * @param object The <code>Course</code> object to clone
     * @return The new <code>Course</code> object
     */
    final Course cloneObject(Course object) {
        Course newObject = null;
        if (object != null) {
            newObject = newCourse();
            copyAttributes(object,newObject,false);
            copyRelatedOwners(object,newObject);
        }
        return newObject;
    }

    /**
     * For this object selection role find the root roles data object in the
     * <code>ObjectSelection</code>.
     * If the root object is a Collection with more than one object, the first
     * object in the Collection is returned.
     *
     * @param objectSelection <code>ObjectSelection</code> to search for the root object
     * @return The <code>Course</code> object
     */
    final Object findRootObject(ObjectSelection objectSelection) {
        Object rootObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("Course")) {
                Collection roots = objectSelection.getRootObjects("Course");
                if (roots != null) {
                    Iterator iter = roots.iterator();
                    if (iter.hasNext()) {
                        rootObject = iter.next();
                    }
                }
            }
        }
        return rootObject;
    }

    /**
     * Find target object in <code>ObjectSelection</code>.
     * The target object is either a domain object or a Collection of such objects.
     *
     * @param objectSelection The <code>ObjectSelection</code> to search.
     * @return Either a single target object or a <code>Collection</code> of target objects.
     */
    final Object findTargetObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("Course")) {
                resultObject = objectSelection.getRootObjects("Course");
                if (!(objectSelection.getTargetRoleName().equals("Course")) && resultObject != null) {
                    Iterator iter = ((Collection)resultObject).iterator();
                    resultObject = iter.hasNext() ? iter.next() : null;
                }
            }
        }
        return resultObject;
    }

    /**
     * Find parent object in an <code>ObjectSelection</code> for this role.
     *
     * @param objectSelection The <code>ObjectSelection></code> to search
     * @return <code>Course</code> is a root role. The method always return null.
     */
    final Object findParentObject(ObjectSelection objectSelection) {
        return null;
    }

    /**
     * Change root object in an <code>ObjectSelection</code>.
     *
     * @param objectSelection The <code>ObjectSelection></code> to change root object.
     * @param oldRoot The object <code>Course</code> to remove as root.
     * @param newRoot The object <code>Course</code> to insert as new  root.
     */
    final void changeRootObject(ObjectSelection objectSelection, Course oldRoot, Course newRoot) {
        if (objectSelection != null) {
            Collection collection = objectSelection.getRootObjects("Course");
            if (collection != null) {
                collection.remove(oldRoot);
                collection.add(newRoot);
            }
        }
    }


    /**
     * Make sure that all related objects to a <code>Course</code> object are loaded.
     *
     * @param object The <code>Course</code> object
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void loadRelated(Course object,Session session) {
        if (object != null) {
            Role role;
            Iterator iter;
            Collection collection;
            Object childObject;
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            if ((getCurrentObjectSelection().getDoFirstLevelManyRelated())) {
                getCurrentObjectSelection().setDoFirstLevelManyRelated(getCurrentObjectSelection().getDoAnyLevelManyRelated());
                dataService.findAssociated(object.getStudentCourses(),session);
                collection = object.getStudentCourses();
                role = findRole("studentCourses");
                iter = collection.iterator();
                while (iter.hasNext()) {
                    ((StudentCoursesDefaultManager)role).loadRelated((StudentCourse)(iter.next()),session);
                }
                getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
            }
        }
    }

    /**
     * Get current object from the result
     * This method is only when this role is above the target role, i.e. it assumes that there
     * is only one member in each collection from the root to this object
     *
     * @param rootResult The Object which is top node in the result
     */
    Course getCurrentObject(Object rootResult) {
        return (Course)rootResult;
    }

    /**
     * Do cleanup of result before sending it to the client. The cleanup will remove unneeded objects
     * to reduce the datatransfer between the server and the client.
     * This method is the entrypoint for cleanup after an insert/update/save with this role as target.
     * For each result root object in the result it will use cleanupAsTarget to remove unneeded objects.
     *
     * @param rootResult The Object who is the top of the path to target
     */
    public void cleanupResult(Object rootResult) {
        if (rootResult instanceof Collection) {
            Iterator iter = ((Collection)rootResult).iterator();
            while (iter.hasNext()) {
                cleanupResultAsTarget((Object)iter.next());
            }
        }
        else
        {
            cleanupResultAsTarget(rootResult);
        }
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for one result root object. For objects on the path to target it will remove
     * all downrelated children, but it will keep any uprelated children. For the target node itself it will
     * only keep those objects actually updated.
     *
     * @param rootResult The object which is the top of the path to target
     */
    public void cleanupResultAsTarget(Object rootResult) {
        if (hookCleanupResultAsTargetStart(rootResult)) {
            if (getParent() == null) {
                Role role;
                role = findRole("studentCourses");
                if (role != null) {
                    ((StudentCoursesDefaultManager)role).cleanupResultAsChild((Course)rootResult);
                }
            }
        }
        hookCleanupResultAsTargetEnd(rootResult);
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for all  objects on the path to target object.
     *
     * @param rootResult The Object who is the top of the path to target
     * @param childRoleName The name of the child role calling this method
     *
     * @return the cleaned object
     */
    public Course cleanupResultAsParent(Object rootResult,String childRoleName) {
        Course thisObject = hookCleanupResultAsParentStart(rootResult,childRoleName);
        if (thisObject == null) {
            if (getParent() == null) {
                thisObject = (Course)rootResult;
                if (thisObject != null) {
                    if (!childRoleName.equals("studentCourses")) {
                        thisObject.setStudentCourses(null);
                    }
                }
            }
        }
        hookCleanupResultAsParentEnd(thisObject,childRoleName);
        return thisObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and searches for a target object of class <code>Course</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will use the main key to find the <code>Course</code> object.
     * <p>
     *
     * @param objectSelection The object selection with all search criteria.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object find(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Course resultObject = null;
        Course targetObject = null;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            if (iter.hasNext()) {
                targetObject = (Course)iter.next();
            }
        }
        resultObject = hookFindStart(objectSelection,targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,objectSelection.getTargetMainKey(),objectSelection.getFindData(),ctx,session);
            if (resultObject != null) {
                findDownRelated(resultObject,ctx,session);
            } 
            if (getParent() == null) {
                if (resultObject != null) {
                    rootList.add(resultObject);
                }
            }
            hookFindEnd(objectSelection,resultObject,ctx,session);
        }
        return rootList;
    }

    /**
     * Find a single <code>Course</code> object in the database.
     * <p>
     * The method uses the search criteria defined in the <code>findData</code> parameter. Without any <code>findData</code>,
     * the method uses the targetKey to find the <code>Course</code> object. The targetKey must be a unique attribute or group.
     * Without any targetKey the main key is chosen as the first unique key found where the all attributes are part of the
     * object selection. The unique keys are examined in the following sequence:
     * <ul>
     *     <li> The primary key
     *     <li> Attributes specified as unique
     *     <li> Groups specified as unique
     * </ul>
     *
     * @param targetObject The target <code>Course</code> object with the key attributes.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object found.
     */
    public Course findSingle(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Course resultObject = hookFindSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            Class clazz = Course.class;
            List keyAttributes = null;
            String primaryKey = getPrimaryKey();
            if (targetKey != null) {
                keyAttributes = getKeyAttributes(targetKey);
                if (primaryKey != null && !(primaryKey.equals(targetKey))) {
                    primaryKey = null;
                }
            }
            else {
                keyAttributes = getKeyAttributes(primaryKey != null ? primaryKey : getMainKey());
            }
            if (primaryKey == null && keyAttributes == null && findData == null) {
                Object[] args = { "Course", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NO_KEY_DEFINED, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            if (findData != null || targetObject != null) {
                if (primaryKey != null) {
                    Serializable keyObject;
                    if (primaryKey.equals("code")) {

                        keyObject = targetObject != null ? (Serializable)TypeTool.toObject(targetObject.getCode()) : null;
                        if (keyObject != null || findData != null) {
                            resultObject = (Course)dataService.find(clazz,keyObject,findData,session);
                        }
                    }
                    else if (primaryKey.equals("id")) {

                        keyObject = targetObject != null ? (Serializable)TypeTool.toObject(targetObject.getId()) : null;
                        if (keyObject != null || findData != null) {
                            resultObject = (Course)dataService.find(clazz,keyObject,findData,session);
                        }
                    }
                    else {
                        resultObject = (Course)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                    }
                }
                else {
                    resultObject = (Course)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                }
            }
        }
        if (!hookFindSingleEnd(resultObject,ctx,session)) {
            resultObject = null;
        }
        return resultObject;
    }

    /**
     * From a <code>Course</code> object find all down related objects of this role.
     * <p>
     * An down related object to an object/role in the object selction is an object connected to its parent object
     * in the object selction thru an association where the parent object is the owner object in the association and the
     * object itself is the member object in the association.
     *
     * @param object The database object to find all down related from.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void findDownRelated(Course object, ClientContext ctx, Session session) {
        if (hookFindDownRelatedStart(object,ctx,session)) {
            if (object != null) {
                Role role;
                if (getCurrentObjectSelection().getDoFirstLevelManyRelated()) {
                    getCurrentObjectSelection().setDoFirstLevelManyRelated(getCurrentObjectSelection().getDoAnyLevelManyRelated());
                    role = findRole("studentCourses");
                    ((StudentCoursesDefaultManager)role).findAsRelated(object,ctx,session);
                    getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
                } else {
                    object.setStudentCourses(null);
                }
            }
        }
        hookFindDownRelatedEnd(object,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and finds all target objects of class <code>Course</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will return all occurences of <code>Course</code>. Each <code>Course</code> object
     * returned will also contain all uprelated child objects. 
     *
     * @param objectSelection The object selection
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return List of <code>Course</code> objects found.
     */
    public List<?> findAll(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        if (objectSelection.getFindData() != null && (objectSelection.getFindData().getDeepFindAll())) {
            objectSelection.setDoOneRelated(true);
            objectSelection.setDoFirstLevelManyRelated(true);
            objectSelection.setDoAnyLevelManyRelated(true);
        }
        List resultList = null;
        Class clazz = Course.class;
        resultList = hookFindAllStart(clazz,objectSelection.getFindData(),ctx,session);
        if (resultList == null) {
            Course targetObject = null;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                if (iter.hasNext()) {
                    targetObject = (Course)iter.next();
                }
            }
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            resultList = dataService.findAll(clazz,targetObject,objectSelection.getFindData(),session);
            if (resultList != null) {
                Course object;
                Iterator iter = resultList.iterator();
                while (iter.hasNext()) {
                    object = (Course)iter.next();
                    findDownRelated(object,ctx,session);
                }
            }
        }
        hookFindAllEnd(resultList,ctx,session);
        return resultList;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and saves a target object of class <code>Course</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object save(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Course resultObject = null;
        Course targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Course)iter.next();
                ActionType action = ActionType.SAVE;
                if (objectSelection.getActions() != null) {
                    action = (ActionType)(objectSelection.getActions().get(targetObject));
                    if (action == null) action = ActionType.SAVE;
                }
                switch (action) {
                    case SAVE:
                        resultObject = save(targetObject, ctx, session);
                        break;
                    case INSERT:
                        resultObject = insert(targetObject, ctx, session);
                        break;
                    case UPDATE:
                        resultObject = update(targetObject, ctx, session);
                        break;
                    case DELETE:
                        delete(targetObject, ctx, session);
                        resultObject = null;
                        break;
                    case CONNECT:
                        break;
                    case DISCONNECT:
                        resultObject = null;
                        break;
                    default:
                    {
                        Object[] args = { action.name() };
                        Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UNKNOWN_SERVICE_ACTION, args);
                        MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                        throw new GenovaServiceException(msg);
                    }
                }
                if (resultObject != null) {
                    rootList.add(resultObject);
                }
            }
        }
        return rootList;
    }

    /**
     * Save one <code>Course</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the database.
     *
     * @param targetObject The <code>Course</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as updated/inserted into the database.
     */
    public Course save(Course targetObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Course resultObject;
        resultObject = hookSaveStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = saveSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            saveDownRelated(targetObject,resultObject,setsContainAllRelated,ctx,session);
        }
        hookSaveEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Save a single <code>Course</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the databse.
     *
     * @param targetObject The <code>Course</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as updated/inserted into the database.
     */
    public Course saveSingle(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Course resultObject = null;
        resultObject = hookSaveSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                resultObject = updateSingle(targetObject,targetKey,findData,ctx,session);
            }
            else {
                resultObject = insertSingle(targetObject,targetKey,findData,ctx,session);
            }
        }
        hookSaveSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>Course</code> object save all its down related objects
     * <p>
     * The action called for each child role depends on thats role legal function specification in the object selection.
     *
     * @param clientObject The <code>Course</code> object with it's child objects as recieved from the client.
     * @param dbObject The <code>Course</code> object with it's child objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void saveDownRelated(Course clientObject, Course dbObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        if (hookSaveDownRelatedStart(clientObject,dbObject,ctx,session)) {
            if (clientObject != null && dbObject != null) {
                Role role;
                if ((getCurrentObjectSelection().getDoFirstLevelManyRelated())) {
                    getCurrentObjectSelection().setDoFirstLevelManyRelated(getCurrentObjectSelection().getDoAnyLevelManyRelated());
                    role = findRole("studentCourses");
                    ((StudentCoursesDefaultManager)role).saveAsRelated(clientObject,dbObject,setsContainAllRelated,ctx,session);
                    getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
                }
            }
        }
        hookSaveDownRelatedEnd(clientObject,dbObject,ctx,session);
    }

    /**
     * Save a <code>Course</code> object of this role as a parent.
     * <p>
     * Saving an object as a parent, will also try to save the objects up related child objects.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param object The <code>Course</code> object as sent from the client.
     * @param root The array will contain the root object at return
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as updated/inserted/identified in the database.
     */
    public Course saveAsParent(ObjectSelection objectSelection, Course object, Object root[], ClientContext ctx,Session session) {
        Course resultObject = null;
        resultObject = hookSaveAsParentStart(objectSelection,object,ctx,session);
        if (resultObject == null) {
            if (object != null) {
                if (getCurrentObjectSelection().getDoParents()) {
                    resultObject = saveSingle(object,null,null,ctx,session);
                } else {
                    resultObject = identifySingle(object,ctx,session);
                }
            }
        }
        if (getParent() == null) {
            root[0] = resultObject;
        }
        hookSaveAsParentEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Identify a single <code>Course</code> object in the database.
     * <p>
     * If the target object does not exist in the database an exception in thrown.
     *
     * @param object The <code>Course</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as it is in the database.
     */
    public Course identifySingle(Course object,ClientContext ctx,Session session)
    {
        Course resultObject = hookIdentifySingleStart(object,ctx,session);
        if (resultObject == null) {
            resultObject = (Course)cloneObject(object);
            resultObject = findSingle(resultObject,null,null,ctx,session);
            if (resultObject == null) {
                Object[] args = { "Course", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_IDENTIFY_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookIdentifySingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and inserts a target object of class <code>Course</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object insert(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Course resultObject = null;
        Course targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Course)iter.next();
                resultObject = insert(targetObject, ctx, session);
                rootList.add(resultObject);
            }
        }
        return rootList;
    }

    /**
     * Insert one <code>Course</code> object and its related objects.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Course</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as inserted into the database.
     */
    Course insert(Course targetObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Course resultObject;
        resultObject = hookInsertStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = insertSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            saveDownRelated(targetObject,resultObject,setsContainAllRelated,ctx,session);
        }
        hookInsertEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Insert a single <code>Course</code> object into the database.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Course</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as updated into the database.
     */
    public Course insertSingle(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Course resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
        if (!isIdentical(targetObject,resultObject)) {
            Course tmpObject = hookInsertSingleStart(targetObject,targetKey,findData,ctx,session);
            if (tmpObject == null) {
                if (resultObject == null) {
                    resultObject = cloneObject(targetObject);
                    DomainUtil.setLockFlag(resultObject,null);
                    DataService dataService = DataServiceImpl.getDataServiceImpl();
                    dataService.insert(resultObject,session); 
                }
                else {
                    Object[] args = { "Course", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_INSERT_ON_EXISTING, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
            }
            else {
              resultObject = tmpObject;
            }
            TriggerInvoker.invoke(resultObject,TriggerType.INSERT, getCurrentObjectSelection().getTargetRoleName().equals("Course"), ctx, session);
            hookInsertSingleEnd(resultObject,ctx,session);
        }
        return resultObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and updates a target object of class <code>Course</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object update(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Course resultObject = null;
        Course targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Course)iter.next();
                resultObject = update(targetObject, ctx, session);
                rootList.add(resultObject);
            }
        }
        return rootList;
    }

    /**
     * Update one <code>Course</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Course</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as updated in the database.
     */
    public Course update(Course targetObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Course resultObject;
        resultObject = hookUpdateStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = updateSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            saveDownRelated(targetObject,resultObject,setsContainAllRelated,ctx,session);
        }
        hookUpdateEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }


    /**
     * Update a single <code>Course</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Course</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Course</code> object as updated into the database.
     */
    public Course updateSingle(Course targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Course resultObject = null;
        resultObject = hookUpdateSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                if (!isIdentical(targetObject,resultObject)) {
                    if (DomainUtil.hasLockFlag(resultObject)) {
                        Serializable targetFlag = DomainUtil.getLockFlag(targetObject);
                        Serializable resultFlag = DomainUtil.getLockFlag(resultObject);
                        if (targetFlag == null || (!(DomainUtil.equalsLockFlag(targetFlag,resultFlag)))) {
                            Object[] args = { "Course" };
                            Message msg = MessageSystem.getMessageFactory().getMessage(targetFlag == null ? CRuntimeMsg.SM_NO_LOCKFLAG_VALUE : CRuntimeMsg.SM_UPDATED_BY_ANOTHER_USER, args);
                            MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                            throw new GenovaServiceException(msg);
                        }
                   }
                   copyAttributes(targetObject,resultObject,true);
                   copyRelatedOwners(targetObject,resultObject);
                }
                TriggerInvoker.invoke(resultObject,TriggerType.UPDATE, getCurrentObjectSelection().getTargetRoleName().equals("Course"), ctx, session);
            }
            else {
                Object[] args = { "Course", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UPDATE_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookUpdateSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and deletes a target object of class <code>Course</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object delete(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Course targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Course)iter.next();
                delete(targetObject,ctx,session);
            }
        }
        return rootList;
    }

    /**
     * Delete a single <code>Course</code> object and all it's related objects in the database.
     *
     * @param targetObject The <code>Course</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void delete(Course targetObject,ClientContext ctx,Session session) {
        Course resultObject = null;
        if (hookDeleteStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            deleteRelated(resultObject,ctx,session);
            deleteSingle(resultObject,ctx,session);
        }
        hookDeleteEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Delete a single <code>Course</code> object in the database.
     *
     * @param object The <code>Course</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteSingle(Course object,ClientContext ctx,Session session) {
        if (hookDeleteSingleStart(object,ctx,session)) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            dataService.delete(object,session);
            TriggerInvoker.invoke(object,TriggerType.DELETE, getCurrentObjectSelection().getTargetRoleName().equals("Course"), ctx, session);
        }
        hookDeleteSingleEnd(ctx,session);
    }
    /**
     * From a <code>Course</code> object delete all its related objects
     * <p>
     * The action called for each child role depends on thats role legal function specification in the object selection.
     *
     * @param object The <code>Course</code> object with it's child objects as recieved from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteRelated(Course object, ClientContext ctx, Session session) {
        Role childRole;
        if (hookDeleteRelatedStart(object,ctx,session)) {
            if (getCurrentObjectSelection().getDoFirstLevelManyRelated()) {
                getCurrentObjectSelection().setDoFirstLevelManyRelated(getCurrentObjectSelection().getDoAnyLevelManyRelated());
                childRole = findRole("studentCourses");
                if (childRole != null) {
                    ((StudentCoursesDefaultManager)childRole).deleteAsRelated(object,ctx,session);
                }
                getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
            }
        }
        hookDeleteRelatedEnd(object,ctx,session);
    }


    /**
     * This method is part of the <code>Manager</code> Interface and connects a target object of class <code>Course</code> to its parent node.
     * This is a root role and the method is dummy.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object connect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        return null;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and disconnects a target object of class <code>Course</code> from its parent node.
     * This is a root role and the method is dummy.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object disconnect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        return null;
    }
   
    /**
     * This method is part of the <code>Manager</code> Interface and gets the target <code>Course</code> object the database.
     *
     * @param objectSelection The <code>ObjectSelection</code> containing the data from the client.
     * @param navigation
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return Object
     */
    public Object get(ObjectSelection objectSelection, ENavigation navigation, ClientContext ctx, Session session) {
        return null;
    }
}
