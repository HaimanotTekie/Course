// Generated with Genova.

package no.course.service.student_os.generated;

import no.course.domain.Student;

import java.io.Serializable;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.List;
import java.util.LinkedList;
import java.util.Collection;
import java.util.Iterator;

import no.genova.dataaccess.Session;
import no.genova.jgrape.DataService;
import no.genova.jgrape.DataServiceImpl;
import no.genova.jgrape.Role;
import no.genova.jgrape.trigger.JGrapeTrigger.TriggerType;
import no.genova.jgrape.trigger.TriggerInvoker;
import no.genova.service.enumerator.ENavigation;
import no.genova.domain.DomainUtil;
import no.genova.support.ObjectSelection;
import no.genova.support.ClientContext;
import no.genova.support.FindData;
import no.genova.support.TypeTool;
import no.genova.support.ActionType;
import no.genova.exception.GenovaServiceException;
import no.genova.message.Message;
import no.genova.message.MessageFactory;
import no.genova.message.MessageSystem;
import no.genova.message.CRuntimeMsg;

/**
 * The <code>Student2DefaultManager</code> class is generated by the Genova Service Generator from the object selection <code>Student_os</code>.
 * <p>
 * The java file containing this class should not be altered. All changes will be lost when the class is regenerated.
 * <p>
 * The class contains all methods used to manipulate the object selection role <code>Student2</code>
 * <p>
 * The role Student2 data objects are of class <code>no.course.domain.Student</code>;
 * <p>
 * <code>Student2</code> is a root role.
 * <p>
 * The <code>Student2</code> is a leaf role in the object selection <code>Student_os</code>
 * <p>
 * Object selection role documentation:
 * <br>
 * 
 * <p>
 * Class documentation:
 * <br>
 * 
 */
@SuppressWarnings("all")
abstract public class Student2DefaultManager extends Role {

    /**
    * Contains the result after save/update/insert action. The parent object is the key object of this map
    */
    Map resultMap = new HashMap();


    /**
     * Hook method called at start of <code>cleanupResultAsTarget</code> for role <code>Student2</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsTarget</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsTarget</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param rootResult The root node for the target node
     * @return true.
     */
    protected boolean hookCleanupResultAsTargetStart(Object rootResult) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsTarget</code> for role <code>Student2</code>.
     *
     * @param resultObject The root node for the target node
     */
    protected void hookCleanupResultAsTargetEnd(Object resultObject) {
    }

    /**
     * Hook method called at start of <code>find</code> for role <code>Student2</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>find</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>find</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>find</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the search data for the target.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookFindStart(ObjectSelection objectSelection,Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>find</code> for <code>Student2</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>findSingle</code> will return the object found without futher actions.</li>
     *    <li>null: <code>findSingle</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with search data.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookFindSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findSingle</code> will return null.</li>
     *    <li>true: <code>findSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param resultObject The <code>Student</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true
     */
    protected boolean hookFindSingleEnd(Student resultObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at start of <code>findAll</code> for role <code>Student2</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>List</code> with the resulting <code>Student</code> objects: <code>findAll</code> will return the list to the client without futher actions.</li>
     *    <li>null: <code>findAll</code> will do its search for the wanted records.</li>
     *    <li>GenovaBaseException: findAll will be aborted.</li>
     * </ul>
     *
     * @param clazz The class of the target object of type <code>Student</code>.
     * @param findData The search criteria. A null reference means using default search.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null
     */
    protected List hookFindAllStart(Class clazz, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findAll</code> for <code>Student2</code>
     * <p>
     *
     * @param resultList The list of <code>Student</code> objects found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     */
    protected void hookFindAllEnd(List resultList, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>save</code> for role <code>Student2</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>save</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>save</code> will do its saving for the target object.</li>
     *    <li>GenovaBaseException: <code>save</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookSaveStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>save</code> for <code>Student2</code>.
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object saved: <code>saveSingle</code> will return the object saved without futher actions.</li>
     *    <li>null: <code>saveSingle</code> will do the saving of the target object.</li>
     *    <li>GenovaBaseException: <code>saveSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with data to be saved.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookSaveSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>saveSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveSingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifySingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object identified: <code>identifySingle</code> will return the object identified without futher actions.</li>
     *    <li>null: <code>identifySingle</code> will do identify of the target object.</li>
     *    <li>GenovaBaseException: <code>identifySingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The Student object with data to be identified in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookIdentifySingleStart(Student object, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>identifySingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifySingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insert</code> for role <code>Student2</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>insert</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>insert</code> will do its inserting for the target object.</li>
     *    <li>GenovaBaseException: <code>insert</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookInsertStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insert</code> for <code>Student2</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object saved: <code>insertSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>insertSingle</code> will do the inserting of the target object.</li>
     *    <li>GenovaBaseException: <code>insertSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookInsertSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insertSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertSingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>update</code> for role <code>Student2</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the resulting object: <code>update</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>update</code> will do its updating for the target object.</li>
     *    <li>GenovaBaseException: <code>update</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookUpdateStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>update</code> for <code>Student2</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>Student</code> with the object saved: <code>updateSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>updateSingle</code> will do the updating of the target object.</li>
     *    <li>GenovaBaseException: <code>updateSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The Student object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected Student hookUpdateSingleStart(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>updateSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>Student</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateSingleEnd(Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>delete</code> for role <code>Student2</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>delete</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>delete</code> will continue.</li>
     *    <li>GenovaBaseException: <code>delete</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>Student</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteStart(ObjectSelection objectSelection, Student targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>delete</code> for <code>Student2</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>Student</code> object that was deleted.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteEnd(ObjectSelection objectSelection, Student resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteSingle</code> will return without futher actions.</li>
     *    <li>true: <code>deleteSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The <code>Student</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteSingleStart(Student object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteSingle</code> for an object.
     * <p>
     *
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteSingleEnd(ClientContext ctx, Session session) {
    }

    /**
     * Hook method called from <code>initializeRole</code>. This hook may be used to override the key
     * definitions for the role.
     * <p>
     * When overriding this hook has two possible exits:
     * <ul>
     *    <li>false: Don't do the default initialization of class' keys<li>
     *    <li>true: Do the default initialization of the class' keys<li>
     * </ul>
     *
     * @return true.
     */
    protected boolean hookInitializeKeys() {
        return true;
    }

    /**
     * Initialize this role manager.
     * The method initializes super before own initialization.
     * 
     * @param applicationName Name of the application
     * @param name Name of the role.
     * @param parent Parent role manager. It should be null.
     */
    final public void initializeRole(String applicationName, String name, Role parent) {
        super.initializeRole(applicationName,name,parent);
        getIncludedAttributes().add("age");
        getIncludedAttributes().add("id");
        getIncludedAttributes().add("name");
        getIncludedAttributes().add("studentNr");
        if (hookInitializeKeys()) {
            Key key;
            key = addKey("id",true,true);
            key.addAttribute("id");
        }
        resultMap.clear();
    }

    /**
     * Check if two <code>Student<code> objects are identical.
     * They are identical if all attributes are equals() ( == for primitives) and
     * all uprelated points to the same objects
     *
     * @param firstObject The first <code>Student</code> object.
     * @param secondObject The second <code>Student</code> object.
     * @return true if the objects are identical
     */
    public boolean isIdentical(Student firstObject, Student secondObject) {
        boolean identical = true;
        if (firstObject != null && secondObject != null && firstObject != secondObject) {
           if (identical) {
               identical = firstObject.getAge() == secondObject.getAge();
           }
           if (identical) {
               identical = firstObject.getId() == secondObject.getId();
           }
           if (identical) {
               Object a1 = firstObject.getName();
               Object a2 = secondObject.getName();
               identical = (a1 != null) ? a1.equals(a2) : a2 == null;
           }
           if (identical) {
               identical = firstObject.getStudentNr() == secondObject.getStudentNr();
           }
        }
        else {
           identical = firstObject == secondObject;
        }
        return identical;
    }

    /**
     * Copy all attributes between two <code>Student</code> objects.
     * The method copies the lock flag too, if the dbms implementation is with optimistic locking.
     *
     * @param fromObject The <code>Student</code> object to copy from.
     * @param toObject The <code>Student</code> object to copy to.
     * @param includedOnly true: Copy only attributes included in this object selection role.
     *                     false: Copy excludede attributes also.
     */
    final void copyAttributes(Student fromObject, Student toObject, boolean includedOnly) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
            toObject.setAge(fromObject.getAge());
            toObject.setId(fromObject.getId());
            toObject.setName(fromObject.getName());
            toObject.setStudentNr(fromObject.getStudentNr());
            DomainUtil.setLockFlag(toObject,DomainUtil.getLockFlag(fromObject));
        }
    }

    /**
     * Copy references to associated objects between two <code>Student</code> objects.
     * The method copies the reference to the parent object if this role is a member role
     * of its parent and the association is navigable to the parent.
     * The method copies the reference to all child objects if this role is a member role
     * of its child. In this case the association will always be navigable to the child.
     *
     * @param fromObject The <code>Student</code> object to copy from
     * @param toObject The <code>Student</code> object to copy to
     */
    final void copyRelatedOwners(Student fromObject, Student toObject) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
        }
    }

    /**
     * Generate a new <code>Student</code> object
     *
     * @return the new <code>Student</code> object
     */
    final Student newStudent() {
        Student object = new Student();
        return object;
    }

    /**
     * Clone a <code>Student</code> object. The method copies
     * attributes using <code>copyAttributes</code> and references to associated
     * objects using <code>copyRelatedOwners</code>. Other object references are
     * not copied.
     *
     * @param object The <code>Student</code> object to clone
     * @return The new <code>Student</code> object
     */
    final Student cloneObject(Student object) {
        Student newObject = null;
        if (object != null) {
            newObject = newStudent();
            copyAttributes(object,newObject,false);
            copyRelatedOwners(object,newObject);
        }
        return newObject;
    }

    /**
     * For this object selection role find the root roles data object in the
     * <code>ObjectSelection</code>.
     * If the root object is a Collection with more than one object, the first
     * object in the Collection is returned.
     *
     * @param objectSelection <code>ObjectSelection</code> to search for the root object
     * @return The <code>Student2</code> object
     */
    final Object findRootObject(ObjectSelection objectSelection) {
        Object rootObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("Student2")) {
                Collection roots = objectSelection.getRootObjects("Student2");
                if (roots != null) {
                    Iterator iter = roots.iterator();
                    if (iter.hasNext()) {
                        rootObject = iter.next();
                    }
                }
            }
        }
        return rootObject;
    }

    /**
     * Find target object in <code>ObjectSelection</code>.
     * The target object is either a domain object or a Collection of such objects.
     *
     * @param objectSelection The <code>ObjectSelection</code> to search.
     * @return Either a single target object or a <code>Collection</code> of target objects.
     */
    final Object findTargetObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("Student2")) {
                resultObject = objectSelection.getRootObjects("Student2");
                if (!(objectSelection.getTargetRoleName().equals("Student2")) && resultObject != null) {
                    Iterator iter = ((Collection)resultObject).iterator();
                    resultObject = iter.hasNext() ? iter.next() : null;
                }
            }
        }
        return resultObject;
    }

    /**
     * Find parent object in an <code>ObjectSelection</code> for this role.
     *
     * @param objectSelection The <code>ObjectSelection></code> to search
     * @return <code>Student2</code> is a root role. The method always return null.
     */
    final Object findParentObject(ObjectSelection objectSelection) {
        return null;
    }

    /**
     * Change root object in an <code>ObjectSelection</code>.
     *
     * @param objectSelection The <code>ObjectSelection></code> to change root object.
     * @param oldRoot The object <code>Student</code> to remove as root.
     * @param newRoot The object <code>Student</code> to insert as new  root.
     */
    final void changeRootObject(ObjectSelection objectSelection, Student oldRoot, Student newRoot) {
        if (objectSelection != null) {
            Collection collection = objectSelection.getRootObjects("Student2");
            if (collection != null) {
                collection.remove(oldRoot);
                collection.add(newRoot);
            }
        }
    }


    /**
     * Do cleanup of result before sending it to the client. The cleanup will remove unneeded objects
     * to reduce the datatransfer between the server and the client.
     * This method is the entrypoint for cleanup after an insert/update/save with this role as target.
     * For each result root object in the result it will use cleanupAsTarget to remove unneeded objects.
     *
     * @param rootResult The Object who is the top of the path to target
     */
    public void cleanupResult(Object rootResult) {
        if (rootResult instanceof Collection) {
            Iterator iter = ((Collection)rootResult).iterator();
            while (iter.hasNext()) {
                cleanupResultAsTarget((Object)iter.next());
            }
        }
        else
        {
            cleanupResultAsTarget(rootResult);
        }
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for one result root object. For objects on the path to target it will remove
     * all downrelated children, but it will keep any uprelated children. For the target node itself it will
     * only keep those objects actually updated.
     *
     * @param rootResult The object which is the top of the path to target
     */
    public void cleanupResultAsTarget(Object rootResult) {
        if (hookCleanupResultAsTargetStart(rootResult)) {
        }
        hookCleanupResultAsTargetEnd(rootResult);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and searches for a target object of class <code>Student</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will use the main key to find the <code>Student</code> object.
     * <p>
     *
     * @param objectSelection The object selection with all search criteria.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object find(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject = null;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            if (iter.hasNext()) {
                targetObject = (Student)iter.next();
            }
        }
        resultObject = hookFindStart(objectSelection,targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,objectSelection.getTargetMainKey(),objectSelection.getFindData(),ctx,session);
            if (getParent() == null) {
                if (resultObject != null) {
                    rootList.add(resultObject);
                }
            }
            hookFindEnd(objectSelection,resultObject,ctx,session);
        }
        return rootList;
    }

    /**
     * Find a single <code>Student</code> object in the database.
     * <p>
     * The method uses the search criteria defined in the <code>findData</code> parameter. Without any <code>findData</code>,
     * the method uses the targetKey to find the <code>Student</code> object. The targetKey must be a unique attribute or group.
     * Without any targetKey the main key is chosen as the first unique key found where the all attributes are part of the
     * object selection. The unique keys are examined in the following sequence:
     * <ul>
     *     <li> The primary key
     *     <li> Attributes specified as unique
     *     <li> Groups specified as unique
     * </ul>
     *
     * @param targetObject The target <code>Student</code> object with the key attributes.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object found.
     */
    public Student findSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = hookFindSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            Class clazz = Student.class;
            List keyAttributes = null;
            String primaryKey = getPrimaryKey();
            if (targetKey != null) {
                keyAttributes = getKeyAttributes(targetKey);
                if (primaryKey != null && !(primaryKey.equals(targetKey))) {
                    primaryKey = null;
                }
            }
            else {
                keyAttributes = getKeyAttributes(primaryKey != null ? primaryKey : getMainKey());
            }
            if (primaryKey == null && keyAttributes == null && findData == null) {
                Object[] args = { "Student", "Student_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NO_KEY_DEFINED, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            if (findData != null || targetObject != null) {
                if (primaryKey != null) {
                    Serializable keyObject;
                    if (primaryKey.equals("id")) {

                        keyObject = targetObject != null ? (Serializable)TypeTool.toObject(targetObject.getId()) : null;
                        if (keyObject != null || findData != null) {
                            resultObject = (Student)dataService.find(clazz,keyObject,findData,session);
                        }
                    }
                    else {
                        resultObject = (Student)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                    }
                }
                else {
                    resultObject = (Student)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                }
            }
        }
        if (!hookFindSingleEnd(resultObject,ctx,session)) {
            resultObject = null;
        }
        return resultObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and finds all target objects of class <code>Student</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will return all occurences of <code>Student</code>. Each <code>Student</code> object
     * returned will also contain all uprelated child objects. 
     *
     * @param objectSelection The object selection
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return List of <code>Student</code> objects found.
     */
    public List<?> findAll(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        if (objectSelection.getFindData() != null && (objectSelection.getFindData().getDeepFindAll())) {
            objectSelection.setDoOneRelated(true);
            objectSelection.setDoFirstLevelManyRelated(true);
            objectSelection.setDoAnyLevelManyRelated(true);
        }
        List resultList = null;
        Class clazz = Student.class;
        resultList = hookFindAllStart(clazz,objectSelection.getFindData(),ctx,session);
        if (resultList == null) {
            Student targetObject = null;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                if (iter.hasNext()) {
                    targetObject = (Student)iter.next();
                }
            }
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            resultList = dataService.findAll(clazz,targetObject,objectSelection.getFindData(),session);
        }
        hookFindAllEnd(resultList,ctx,session);
        return resultList;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and saves a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object save(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                ActionType action = ActionType.SAVE;
                if (objectSelection.getActions() != null) {
                    action = (ActionType)(objectSelection.getActions().get(targetObject));
                    if (action == null) action = ActionType.SAVE;
                }
                switch (action) {
                    case SAVE:
                        resultObject = save(targetObject, ctx, session);
                        break;
                    case INSERT:
                        resultObject = insert(targetObject, ctx, session);
                        break;
                    case UPDATE:
                        resultObject = update(targetObject, ctx, session);
                        break;
                    case DELETE:
                        delete(targetObject, ctx, session);
                        resultObject = null;
                        break;
                    case CONNECT:
                        break;
                    case DISCONNECT:
                        resultObject = null;
                        break;
                    default:
                    {
                        Object[] args = { action.name() };
                        Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UNKNOWN_SERVICE_ACTION, args);
                        MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                        throw new GenovaServiceException(msg);
                    }
                }
                if (resultObject != null) {
                    rootList.add(resultObject);
                }
            }
        }
        return rootList;
    }

    /**
     * Save one <code>Student</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the database.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated/inserted into the database.
     */
    public Student save(Student targetObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Student resultObject;
        resultObject = hookSaveStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = saveSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
        }
        hookSaveEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Save a single <code>Student</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the databse.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated/inserted into the database.
     */
    public Student saveSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = null;
        resultObject = hookSaveSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                resultObject = updateSingle(targetObject,targetKey,findData,ctx,session);
            }
            else {
                resultObject = insertSingle(targetObject,targetKey,findData,ctx,session);
            }
        }
        hookSaveSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Identify a single <code>Student</code> object in the database.
     * <p>
     * If the target object does not exist in the database an exception in thrown.
     *
     * @param object The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as it is in the database.
     */
    public Student identifySingle(Student object,ClientContext ctx,Session session)
    {
        Student resultObject = hookIdentifySingleStart(object,ctx,session);
        if (resultObject == null) {
            resultObject = (Student)cloneObject(object);
            resultObject = findSingle(resultObject,null,null,ctx,session);
            if (resultObject == null) {
                Object[] args = { "Student", "Student_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_IDENTIFY_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookIdentifySingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and inserts a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object insert(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                resultObject = insert(targetObject, ctx, session);
                rootList.add(resultObject);
            }
        }
        return rootList;
    }

    /**
     * Insert one <code>Student</code> object and its related objects.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as inserted into the database.
     */
    Student insert(Student targetObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Student resultObject;
        resultObject = hookInsertStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = insertSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
        }
        hookInsertEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Insert a single <code>Student</code> object into the database.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated into the database.
     */
    public Student insertSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
        if (!isIdentical(targetObject,resultObject)) {
            Student tmpObject = hookInsertSingleStart(targetObject,targetKey,findData,ctx,session);
            if (tmpObject == null) {
                if (resultObject == null) {
                    resultObject = cloneObject(targetObject);
                    DomainUtil.setLockFlag(resultObject,null);
                    DataService dataService = DataServiceImpl.getDataServiceImpl();
                    dataService.insert(resultObject,session); 
                }
                else {
                    Object[] args = { "Student", "Student_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_INSERT_ON_EXISTING, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
            }
            else {
              resultObject = tmpObject;
            }
            TriggerInvoker.invoke(resultObject,TriggerType.INSERT, getCurrentObjectSelection().getTargetRoleName().equals("Student2"), ctx, session);
            hookInsertSingleEnd(resultObject,ctx,session);
        }
        return resultObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and updates a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object update(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Student resultObject = null;
        Student targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                resultObject = update(targetObject, ctx, session);
                rootList.add(resultObject);
            }
        }
        return rootList;
    }

    /**
     * Update one <code>Student</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated in the database.
     */
    public Student update(Student targetObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        Student resultObject;
        resultObject = hookUpdateStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            resultObject = updateSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
        }
        hookUpdateEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }


    /**
     * Update a single <code>Student</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>Student</code> object as updated into the database.
     */
    public Student updateSingle(Student targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        Student resultObject = null;
        resultObject = hookUpdateSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                if (!isIdentical(targetObject,resultObject)) {
                    if (DomainUtil.hasLockFlag(resultObject)) {
                        Serializable targetFlag = DomainUtil.getLockFlag(targetObject);
                        Serializable resultFlag = DomainUtil.getLockFlag(resultObject);
                        if (targetFlag == null || (!(DomainUtil.equalsLockFlag(targetFlag,resultFlag)))) {
                            Object[] args = { "Student" };
                            Message msg = MessageSystem.getMessageFactory().getMessage(targetFlag == null ? CRuntimeMsg.SM_NO_LOCKFLAG_VALUE : CRuntimeMsg.SM_UPDATED_BY_ANOTHER_USER, args);
                            MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                            throw new GenovaServiceException(msg);
                        }
                   }
                   copyAttributes(targetObject,resultObject,true);
                   copyRelatedOwners(targetObject,resultObject);
                }
                TriggerInvoker.invoke(resultObject,TriggerType.UPDATE, getCurrentObjectSelection().getTargetRoleName().equals("Student2"), ctx, session);
            }
            else {
                Object[] args = { "Student", "Student_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UPDATE_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookUpdateSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and deletes a target object of class <code>Student</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object delete(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        List rootList = new LinkedList();
        Student targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (Student)iter.next();
                delete(targetObject,ctx,session);
            }
        }
        return rootList;
    }

    /**
     * Delete a single <code>Student</code> object and all it's related objects in the database.
     *
     * @param targetObject The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void delete(Student targetObject,ClientContext ctx,Session session) {
        Student resultObject = null;
        if (hookDeleteStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            deleteSingle(resultObject,ctx,session);
        }
        hookDeleteEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Delete a single <code>Student</code> object in the database.
     *
     * @param object The <code>Student</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteSingle(Student object,ClientContext ctx,Session session) {
        if (hookDeleteSingleStart(object,ctx,session)) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            dataService.delete(object,session);
            TriggerInvoker.invoke(object,TriggerType.DELETE, getCurrentObjectSelection().getTargetRoleName().equals("Student2"), ctx, session);
        }
        hookDeleteSingleEnd(ctx,session);
    }


    /**
     * This method is part of the <code>Manager</code> Interface and connects a target object of class <code>Student</code> to its parent node.
     * This is a root role and the method is dummy.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object connect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        return null;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and disconnects a target object of class <code>Student</code> from its parent node.
     * This is a root role and the method is dummy.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object disconnect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        return null;
    }
   
    /**
     * This method is part of the <code>Manager</code> Interface and gets the target <code>Student</code> object the database.
     *
     * @param objectSelection The <code>ObjectSelection</code> containing the data from the client.
     * @param navigation
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return Object
     */
    public Object get(ObjectSelection objectSelection, ENavigation navigation, ClientContext ctx, Session session) {
        return null;
    }
}
