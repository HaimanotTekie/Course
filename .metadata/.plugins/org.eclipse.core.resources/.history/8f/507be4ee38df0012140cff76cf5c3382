// Generated with Genova.

package no.course.service.application.office.addstudentstocourse_os.generated;

import no.course.domain.Course;
import no.course.domain.StudentCourse;
import no.course.domain.Student;
import no.course.service.application.office.addstudentstocourse_os.AddStudentsToCourse_osOsManager;

import java.io.Serializable;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.List;
import java.util.LinkedList;
import java.util.Collection;
import java.util.Iterator;

import no.genova.dataaccess.Session;
import no.genova.jgrape.DataService;
import no.genova.jgrape.DataServiceImpl;
import no.genova.jgrape.Role;
import no.genova.jgrape.trigger.JGrapeTrigger.TriggerType;
import no.genova.jgrape.trigger.TriggerInvoker;
import no.genova.service.enumerator.ENavigation;
import no.genova.domain.DomainUtil;
import no.genova.support.ObjectSelection;
import no.genova.support.ClientContext;
import no.genova.support.FindData;
import no.genova.support.TypeTool;
import no.genova.support.ActionType;
import no.genova.exception.GenovaServiceException;
import no.genova.message.Message;
import no.genova.message.MessageFactory;
import no.genova.message.MessageSystem;
import no.genova.message.CRuntimeMsg;

/**
 * The <code>StudentCoursesDefaultManager</code> class is generated by the Genova Service Generator from the object selection <code>AddStudentsToCourse_os</code>.
 * <p>
 * The java file containing this class should not be altered. All changes will be lost when the class is regenerated.
 * <p>
 * The class contains all methods used to manipulate the object selection role <code>studentCourses</code>
 * <p>
 * The role studentCourses data objects are of class <code>no.course.domain.StudentCourse</code>;
 * <p>
 * <code>studentCourses</code> is child role of the role <code>Course</code> under the root role <code>Course</code>.
 * <br>
 * It is   member in the association between <code>Course</code> and <code>studentCourses</code>
 * <p>
 * Child roles to <code>studentCourses</code>:
 * <ul>
 * <li><code>student</code></li>
 * </ul>
 * <p>
 * Object selection role documentation:
 * <br>
 * 
 * <p>
 * Class documentation:
 * <br>
 * 
 */
@SuppressWarnings("all")
abstract public class StudentCoursesDefaultManager extends Role {

    /**
    * Contains the result after save/update/insert action. The parent object is the key object of this map
    */
    Map resultMap = new HashMap();


    /**
     * Hook method called at start of <code>cleanupResultAsTarget</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsTarget</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsTarget</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param rootResult The root node for the target node
     * @return true.
     */
    protected boolean hookCleanupResultAsTargetStart(Object rootResult) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsTarget</code> for role <code>studentCourses</code>.
     *
     * @param resultObject The root node for the target node
     */
    protected void hookCleanupResultAsTargetEnd(Object resultObject) {
    }

    /**
     * Hook method called at start of <code>cleanupResultAsParent</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with object. <code>cleanupResultAsParent</code> will return the result without futher actions.</li>
     *    <li>null: <code>cleanupResultAsParent</code> will do the cleanup.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param rootResult The Object which is the top of the path to target
     * @param childRoleName The name of the child role calling this method
     * @return null.
     */
    protected StudentCourse hookCleanupResultAsParentStart(Object rootResult,String childRoleName) {
        return null;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsParent</code> for role <code>studentCourses</code>.
     *
     * @param resultObject The Object which is the target for the cleanup
     * @param childRoleName The name of the child role calling this method
     */
    protected void hookCleanupResultAsParentEnd(StudentCourse resultObject,String childRoleName) {
    }

    /**
     * Hook method called at start of <code>cleanupResultAsChild</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>cleanupResultAsChild</code> will return the result without futher actions.
     *    <li>true: <code>cleanupResultAsChild</code> will continue.</li>
     *    <li>GenovaBaseException: <code>cleanupResult</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The <code>Course<code> object which is parent object in tghis cleanup
     * @return true.
     */
    protected boolean hookCleanupResultAsChildStart(Course parentObject) {
        return true;
    }

    /**
     * Hook method called at end of <code>cleanupResultAsChild</code> for role <code>studentCourses</code>.
     *
     * @param parentObject The <code>Course<code> object which is parent object in tghis cleanup
     */
    protected void hookCleanupResultAsChildEnd(Course parentObject) {
    }

    /**
     * Hook method called at start of <code>find</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the resulting object: <code>find</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>find</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>find</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>StudentCourse</code> object with the search data for the target.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookFindStart(ObjectSelection objectSelection,StudentCourse targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>find</code> for <code>studentCourses</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>StudentCourse</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindEnd(ObjectSelection objectSelection, StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the resulting object: <code>findSingle</code> will return the object found without futher actions.</li>
     *    <li>null: <code>findSingle</code> will do its search for the wanted object.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The StudentCourse object with search data.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookFindSingleStart(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findSingle</code> will return null.</li>
     *    <li>true: <code>findSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param resultObject The <code>StudentCourse</code> object found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true
     */
    protected boolean hookFindSingleEnd(StudentCourse resultObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at start of <code>findUpRelated</code> for a <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findUpRelated</code> will return the result without futher actions.
     * The related objects is expected to be connect to the <code>StudentCourse</code> object.</li>
     *    <li>true: <code>findUpRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findUpRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param object The database <code>StudentCourse</code> object we want to find all up related objects to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookFindUpRelatedStart(StudentCourse object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>findUpRelated</code> for a <code>StudentCourse</code> object.
     * <p>
     *
     * @param object The database <code>StudentCourse</code> object we want to find all up related nodes to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindUpRelatedEnd(StudentCourse object, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findAsRelated</code> for a <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>findAsRelated</code> will return the result without futher actions.
     * The related <code>StudentCourse</code> objects are expected to be connect to the <code>Course</code> parent object.</li>
     *    <li>true: <code>findAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>findAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The database <code>Course</code> object we want to find related <code>StudentCourse</code> to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookFindAsRelatedStart(Course parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>findAsRelated</code> for a <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     *
     * @param parentObject The database <code>Course</code> object we want to find related <code>StudentCourse</code> to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookFindAsRelatedEnd(Course parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>findAll</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>List</code> with the resulting <code>StudentCourse</code> objects: <code>findAll</code> will return the list to the client without futher actions.</li>
     *    <li>null: <code>findAll</code> will do its search for the wanted records.</li>
     *    <li>GenovaBaseException: findAll will be aborted.</li>
     * </ul>
     *
     * @param clazz The class of the target object of type <code>StudentCourse</code>.
     * @param findData The search criteria. A null reference means using default search.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null
     */
    protected List hookFindAllStart(Class clazz, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>findAll</code> for <code>studentCourses</code>
     * <p>
     *
     * @param resultList The list of <code>StudentCourse</code> objects found.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     */
    protected void hookFindAllEnd(List resultList, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>save</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the resulting object: <code>save</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>save</code> will do its saving for the target object.</li>
     *    <li>GenovaBaseException: <code>save</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>StudentCourse</code> object with the data to be saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookSaveStart(ObjectSelection objectSelection, StudentCourse targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>save</code> for <code>studentCourses</code>.
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>StudentCourse</code> object that was saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveEnd(ObjectSelection objectSelection, StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the object saved: <code>saveSingle</code> will return the object saved without futher actions.</li>
     *    <li>null: <code>saveSingle</code> will do the saving of the target object.</li>
     *    <li>GenovaBaseException: <code>saveSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The StudentCourse object with data to be saved.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookSaveSingleStart(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>saveSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>StudentCourse</code> object saved.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveSingleEnd(StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveUpRelated</code> for a <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>saveUpRelated</code> will return the result without futher actions.
     * The related objects is expected to be connect to the <code>StudentCourse</code> object.</li>
     *    <li>true: <code>saveUpRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>saveUpRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param object The database <code>StudentCourse</code> object we want to save all up related objects to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookSaveUpRelatedStart(StudentCourse object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>saveUpRelated</code> for a <code>StudentCourse</code> object.
     *
     * @param object The database <code>StudentCourse</code> object we want to save all up related nodes to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveUpRelatedEnd(StudentCourse object, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveAsRelated</code> for a down related <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>saveAsRelated</code> will return without futher actions.
     * The related <code>StudentCourse</code> objects are expected to be saved and connect to the <code>Course</code> database parent object.</li>
     *    <li>true: <code>saveAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>saveAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connect as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connect as it is in the database before the save.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookSaveAsRelatedStart(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>saveAsRelated</code> for a down related <code>StudentCourse</code> object.
     * <p>
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connect as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connect as it is in the database after the save.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveAsRelatedEnd(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>saveAsParent</code> for a <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the object saved: <code>saveAsParent</code> will return the object identified  without futher actions.</li>
     *    <li>null: <code>saveAsParent</code> will do the saving of the target object.</li>
     *    <li>GenovaBaseException: <code>saveAsParent</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param object The StudentCourse object with data to be identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookSaveAsParentStart(ObjectSelection objectSelection,StudentCourse object,ClientContext ctx,Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>saveAsParent</code> for a <code>StudentCourse</code> object.
     * <p>
     *
     * @param resultObject The <code>StudentCourse</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveAsParentEnd(StudentCourse resultObject,ClientContext ctx,Session session) {
    }
    /**
     * Hook method called at start of <code>saveUpRelatedAsParent</code> for a <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>saveUpRelatedAsParent</code> will return without futher actions.</li>
     *    <li>true: <code>saveUpRelatedAsParent</code> will continue.</li>
     *    <li>GenovaBaseException: <code>saveUpRelatedAsParent</code> will be aborted.</li>
     * </ul>
     *
     * @param object The StudentCourse object with data to be identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected boolean hookSaveUpRelatedAsParentStart(StudentCourse object,ClientContext ctx,Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>saveUpRelatedAsParent</code> for a <code>StudentCourse</code> object.
     * <p>
     *
     * @param resultObject The <code>StudentCourse</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookSaveUpRelatedAsParentEnd(StudentCourse resultObject,ClientContext ctx,Session session) {
    }

    /**
     * Hook method called at start of <code>identifySingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the object identified: <code>identifySingle</code> will return the object identified without futher actions.</li>
     *    <li>null: <code>identifySingle</code> will do identify of the target object.</li>
     *    <li>GenovaBaseException: <code>identifySingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The StudentCourse object with data to be identified in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookIdentifySingleStart(StudentCourse object, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>identifySingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>StudentCourse</code> object identified.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifySingleEnd(StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifyAsRelated</code> for a down related <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>identifyAsRelated</code> will return without futher actions.
     * The related <code>StudentCourse</code> objects are expected to be identified and connected to the <code>Course</code> database parent object.</li>
     *    <li>true: <code>identifyAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>identifyAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as it is in the database befor the identify.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookIdentifyAsRelatedStart(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>identifyAsRelated</code> for a down related <code>StudentCourse</code> object.
     * <p>
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as it is in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifyAsRelatedEnd(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>identifyAsRelated</code> for an up related <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>identifyAsRelated</code> will return without futher actions.
     * The up related <code>StudentCourse</code> objects are expected to be identified and connected to the <code>Course</code> database parent object.</li>
     *    <li>true: <code>identifyAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>identifyAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookIdentifyAsRelatedStart(Course parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>identifyAsRelated</code> for an up related <code>StudentCourse</code> object.
     * <p>
     *
     * @param parentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookIdentifyAsRelatedEnd(Course parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insert</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the resulting object: <code>insert</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>insert</code> will do its inserting for the target object.</li>
     *    <li>GenovaBaseException: <code>insert</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>StudentCourse</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookInsertStart(ObjectSelection objectSelection, StudentCourse targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insert</code> for <code>studentCourses</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>StudentCourse</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertEnd(ObjectSelection objectSelection, StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the object saved: <code>insertSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>insertSingle</code> will do the inserting of the target object.</li>
     *    <li>GenovaBaseException: <code>insertSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The StudentCourse object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookInsertSingleStart(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>insertSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>StudentCourse</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertSingleEnd(StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>insertAsRelated</code> for a down related <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>insertAsRelated</code> will return without futher actions.
     * The related <code>StudentCourse</code> objects are expected to be inserted and connected to the <code>Course</code> database parent object.</li>
     *    <li>true: <code>insertAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>insertAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as it is in the database befor the inserting.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookInsertAsRelatedStart(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>insertAsRelated</code> for a down related <code>StudentCourse</code> object.
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as it is in the database after the inserting.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookInsertAsRelatedEnd(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>update</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the resulting object: <code>update</code> will return the result to the client without futher actions.</li>
     *    <li>null: <code>update</code> will do its updating for the target object.</li>
     *    <li>GenovaBaseException: <code>update</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>StudentCourse</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookUpdateStart(ObjectSelection objectSelection, StudentCourse targetObject, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>update</code> for <code>studentCourses</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>StudentCourse</code> object that was updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateEnd(ObjectSelection objectSelection, StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>A <code>StudentCourse</code> with the object saved: <code>updateSingle</code> will return the object updated without futher actions.</li>
     *    <li>null: <code>updateSingle</code> will do the updating of the target object.</li>
     *    <li>GenovaBaseException: <code>updateSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param targetObject The StudentCourse object with data to be updated.
     * @param targetKey The key to use.
     * @param findData The findData to use.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return null.
     */
    protected StudentCourse hookUpdateSingleStart(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        return null;
    }

    /**
     * Hook method called at end of <code>updateSingle</code> for an object.
     * <p>
     *
     * @param resultObject The <code>StudentCourse</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateSingleEnd(StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>updateAsRelated</code> for a down related <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>updateAsRelated</code> will return without futher actions.
     * The related <code>StudentCourse</code> objects are expected to be updated and connected to the <code>Course</code> database parent object.</li>
     *    <li>true: <code>updateAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>updateAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as it is in the database befor the update.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookUpdateAsRelatedStart(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>updateAsRelated</code> for a down related <code>StudentCourse</code> object.
     *
     * @param clientParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as sent from the client.
     * @param dbParentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connected as it is in the database after the update.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookUpdateAsRelatedEnd(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>delete</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>delete</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>delete</code> will continue.</li>
     *    <li>GenovaBaseException: <code>delete</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>StudentCourse</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteStart(ObjectSelection objectSelection, StudentCourse targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>delete</code> for <code>studentCourses</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>StudentCourse</code> object that was deleted.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteEnd(ObjectSelection objectSelection, StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteSingle</code> will return without futher actions.</li>
     *    <li>true: <code>deleteSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param object The <code>StudentCourse</code> object updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteSingleStart(StudentCourse object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteSingle</code> for an object.
     * <p>
     *
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteSingleEnd(ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteRelated</code> for a <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteRelated</code> will return without futher actions.
     * The related objects is expected to be delete or disonnect to the <code>StudentCourse</code> object.</li>
     *    <li>true: <code>deleteRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param object The database <code>StudentCourse</code> object we want to delete all related objects to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteRelatedStart(StudentCourse object, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteRelated</code> for a <code>StudentCourse</code> object.
     * <p>
     *
     * @param object The database <code>StudentCourse</code> object we have deleted all related nodes to.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteRelatedEnd(StudentCourse object, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>deleteAsRelated</code> for a related <code>StudentCourse</code> object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>deleteAsRelated</code> will return without futher actions.
     * The related <code>StudentCourse</code> objects are expected to be deleted or disconnect from the <code>Course</code> parent object.</li>
     *    <li>true: <code>deleteAsRelated</code> will continue.</li>
     *    <li>GenovaBaseException: <code>deleteAsRelated</code> will be aborted.</li>
     * </ul>
     *
     * @param parentObject The parent object <code>Course</code> with the <code>StudentCourse</code> objects connect as it is in the database before the delete.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDeleteAsRelatedStart(Course parentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>deleteAsRelated</code> for a related <code>StudentCourse</code> object.
     * <p>
     *
     * @param parentObject The parent object <code>Course</code> as it is in the database after the delete.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDeleteAsRelatedEnd(Course parentObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>connect</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>connect</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>connect</code> will continue.</li>
     *    <li>GenovaBaseException: <code>connect</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>StudentCourse</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookConnectStart(ObjectSelection objectSelection, StudentCourse targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>connect</code> for <code>studentCourses</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>StudentCourse</code> object that was connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookConnectEnd(ObjectSelection objectSelection, StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>connectSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>connectSingle</code> will return without futher actions.</li>
     *    <li>true: <code>connectSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>connectSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param dbChildObject The <code>StudentCourse</code> object to be connected.
     * @param dbParentObject The <code>Course</code> object to be connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookConnectSingleStart(StudentCourse dbChildObject, Course dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>connectSingle</code> for an object.
     * <p>
     *
     * @param dbChildObject The <code>StudentCourse</code> object connected.
     * @param dbParentObject The <code>Course</code> object connected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookConnectSingleEnd(StudentCourse dbChildObject, Course dbParentObject,ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>disconnect</code> for role <code>studentCourses</code>.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>disconnect</code> will return the result to the client without futher actions.</li>
     *    <li>true: <code>disconnect</code> will continue.</li>
     *    <li>GenovaBaseException: <code>disconnect</code> will be aborted.</li>
     * </ul>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the client.
     * @param targetObject The target <code>StudentCourse</code> object with the data to be updated.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDisconnectStart(ObjectSelection objectSelection, StudentCourse targetObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>disconnect</code> for <code>studentCourses</code>.
     * <p>
     *
     * @param objectSelection The <code>ObjectSelection</code> with data from the database.
     * @param resultObject The <code>StudentCourse</code> object that was disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDisconnectEnd(ObjectSelection objectSelection, StudentCourse resultObject, ClientContext ctx, Session session) {
    }

    /**
     * Hook method called at start of <code>disconnectSingle</code> for an object.
     * <p>
     * When overriding this hook has three possible exits:
     * <ul>
     *    <li>false: <code>disconnectSingle</code> will return without futher actions.</li>
     *    <li>true: <code>disconnectSingle</code> will continue.</li>
     *    <li>GenovaBaseException: <code>disconnectSingle</code> will be aborted.</li>
     * </ul>
     *
     * @param dbChildObject The <code>StudentCourse</code> object to be disconnected.
     * @param dbParentObject The <code>Course</code> object to be disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return true.
     */
    protected boolean hookDisconnectSingleStart(StudentCourse dbChildObject, Course dbParentObject, ClientContext ctx, Session session) {
        return true;
    }

    /**
     * Hook method called at end of <code>disconnectSingle</code> for an object.
     * <p>
     *
     * @param dbChildObject The <code>StudentCourse</code> object disconnected.
     * @param dbParentObject The <code>Course</code> object disconnected.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    protected void hookDisconnectSingleEnd(StudentCourse dbChildObject, Course dbParentObject,ClientContext ctx, Session session) {
    }

    /**
     * Hook method called from <code>initializeRole</code>. This hook may be used to override the key
     * definitions for the role.
     * <p>
     * When overriding this hook has two possible exits:
     * <ul>
     *    <li>false: Don't do the default initialization of class' keys<li>
     *    <li>true: Do the default initialization of the class' keys<li>
     * </ul>
     *
     * @return true.
     */
    protected boolean hookInitializeKeys() {
        return true;
    }

    /**
     * Initialize this role manager.
     * The method initializes super before own initialization.
     * 
     * @param applicationName Name of the application
     * @param name Name of the role.
     * @param parent Parent role manager. It should be a <code>CourseDefaultManager</code>.
     */
    final public void initializeRole(String applicationName, String name, Role parent) {
        Role role;
        super.initializeRole(applicationName,name,parent);
        getIncludedAttributes().add("id");
        if (hookInitializeKeys()) {
            Key key;
            key = addKey("id",true,true);
            key.addAttribute("id");
        }
        role = AddStudentsToCourse_osOsManager.newRoleManager(applicationName,"student");
        if (role != null) {
            role.initializeRole(applicationName, "student",this);
            getUpRelated().add(role);
        }
        resultMap.clear();
    }

    /**
     * Set the currentObjectSelectionProperty
     * 
     * @param objectSelection New current ObjectSelection
     */
    final public void setCurrentObjectSelection(ObjectSelection objectSelection) {
        super.setCurrentObjectSelection(objectSelection);
        Role role;
        role = findRole("student");
        if (role != null) {
            role.setCurrentObjectSelection(objectSelection);
        }
    }

    /**
     * Check if two <code>StudentCourse<code> objects are identical.
     * They are identical if all attributes are equals() ( == for primitives) and
     * all uprelated points to the same objects
     *
     * @param firstObject The first <code>StudentCourse</code> object.
     * @param secondObject The second <code>StudentCourse</code> object.
     * @return true if the objects are identical
     */
    public boolean isIdentical(StudentCourse firstObject, StudentCourse secondObject) {
        boolean identical = true;
        if (firstObject != null && secondObject != null && firstObject != secondObject) {
           if (identical) {
               identical = firstObject.getId() == secondObject.getId();
           }
           if (identical) {
               identical = firstObject.getCourse() == secondObject.getCourse();
           }
           if (identical) {
               identical = firstObject.getStudent() == secondObject.getStudent();
           }
        }
        else {
           identical = firstObject == secondObject;
        }
        return identical;
    }

    /**
     * Copy all attributes between two <code>StudentCourse</code> objects.
     * The method copies the lock flag too, if the dbms implementation is with optimistic locking.
     *
     * @param fromObject The <code>StudentCourse</code> object to copy from.
     * @param toObject The <code>StudentCourse</code> object to copy to.
     * @param includedOnly true: Copy only attributes included in this object selection role.
     *                     false: Copy excludede attributes also.
     */
    final void copyAttributes(StudentCourse fromObject, StudentCourse toObject, boolean includedOnly) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
            toObject.setId(fromObject.getId());
            DomainUtil.setLockFlag(toObject,DomainUtil.getLockFlag(fromObject));
        }
    }

    /**
     * Copy references to associated objects between two <code>StudentCourse</code> objects.
     * The method copies the reference to the parent object if this role is a member role
     * of its parent and the association is navigable to the parent.
     * The method copies the reference to all child objects if this role is a member role
     * of its child. In this case the association will always be navigable to the child.
     *
     * @param fromObject The <code>StudentCourse</code> object to copy from
     * @param toObject The <code>StudentCourse</code> object to copy to
     */
    final void copyRelatedOwners(StudentCourse fromObject, StudentCourse toObject) {
        if (fromObject != null && toObject != null && fromObject != toObject) {
            toObject.setCourse(fromObject.getCourse());
            Object child;
            child = fromObject.getStudent();
            toObject.setStudent((Student)child);
        }
    }

    /**
     * Generate a new <code>StudentCourse</code> object
     *
     * @return the new <code>StudentCourse</code> object
     */
    final StudentCourse newStudentCourse() {
        StudentCourse object = new StudentCourse();
        return object;
    }

    /**
     * Clone a <code>StudentCourse</code> object. The method copies
     * attributes using <code>copyAttributes</code> and references to associated
     * objects using <code>copyRelatedOwners</code>. Other object references are
     * not copied.
     *
     * @param object The <code>StudentCourse</code> object to clone
     * @return The new <code>StudentCourse</code> object
     */
    final StudentCourse cloneObject(StudentCourse object) {
        StudentCourse newObject = null;
        if (object != null) {
            newObject = newStudentCourse();
            copyAttributes(object,newObject,false);
            copyRelatedOwners(object,newObject);
        }
        return newObject;
    }

    /**
     * For this object selection role find the root roles data object in the
     * <code>ObjectSelection</code>.
     * If the root object is a Collection with more than one object, the first
     * object in the Collection is returned.
     *
     * @param objectSelection <code>ObjectSelection</code> to search for the root object
     * @return The <code>Course</code> object
     */
    final Object findRootObject(ObjectSelection objectSelection) {
        Object rootObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("studentCourses")) {
                Collection roots = objectSelection.getRootObjects("studentCourses");
                if (roots != null) {
                    Iterator iter = roots.iterator();
                    if (iter.hasNext()) {
                        rootObject = iter.next();
                    }
                }
            }
            else if (getParent() != null) {
                rootObject = ((CourseDefaultManager)getParent()).findRootObject(objectSelection);
            }
        }
        return rootObject;
    }

    /**
     * Find target object in <code>ObjectSelection</code>.
     * The target object is either a domain object or a Collection of such objects.
     *
     * @param objectSelection The <code>ObjectSelection</code> to search.
     * @return Either a single target object or a <code>Collection</code> of target objects.
     */
    final Object findTargetObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null) {
            if (objectSelection.getCurrentRootName().equals("studentCourses")) {
                resultObject = objectSelection.getRootObjects("studentCourses");
                if (!(objectSelection.getTargetRoleName().equals("studentCourses")) && resultObject != null) {
                    Iterator iter = ((Collection)resultObject).iterator();
                    resultObject = iter.hasNext() ? iter.next() : null;
                }
            }
            else if (getParent() != null) {
                Course parentObject = (Course)((CourseDefaultManager)getParent()).findTargetObject(objectSelection);
                if (parentObject != null)
                {
                    resultObject = parentObject.getStudentCourses();
                    if (!(objectSelection.getTargetRoleName().equals("studentCourses")) && resultObject != null) {
                        Iterator iter = ((Collection)resultObject).iterator();
                        resultObject = iter.hasNext() ? iter.next() : null;
                    }
                }
            }
        }
        return resultObject;
    }

    /**
     * Find parent object in an <code>ObjectSelection</code> for this role.
     * If the parent instance is inside a collection the method expects
     * this collection to contain one and only one occurence of the parent objects
     *
     * @param objectSelection The <code>ObjectSelection></code> to search
     * @return The parent <code>Course</code> object
     */
    final Course findParentObject(ObjectSelection objectSelection) {
        Object resultObject = null;
        if (objectSelection != null && getParent() != null) {
            String tmp = objectSelection.getTargetRoleName();
            objectSelection.setTargetRoleName("Course");
            resultObject = ((CourseDefaultManager)getParent()).findTargetObject(objectSelection);
            if (resultObject != null && (resultObject instanceof Collection)) {
                Iterator iter = ((Collection)resultObject).iterator();
                resultObject = iter.hasNext() ? (Course)(iter.next()) : null;
            }
            objectSelection.setTargetRoleName(tmp);
        }
        return (Course)resultObject;
    }

    /**
     * Check if a <code>StudentCourse</code> object is child to a parent <code>Course</code> object.
     *
     * @param parentObject The parent <code>Course</code> 
     * @param childObject The child <code>StudentCourse</code> 
     * @param session The <code>DataAccess</code> <code>Session</code>.
     *
     * @return true if childObject is a child of parentObject.
     */
    final boolean isChildPresent(Course parentObject,StudentCourse childObject,Session session) {
        boolean present = false;
        DataService dataService = DataServiceImpl.getDataServiceImpl();
        dataService.findAssociated(parentObject.getStudentCourses(),session);
        Iterator iter = parentObject.getStudentCourses() != null ?
                            parentObject.getStudentCourses().iterator() :
                            null;
        while (iter != null && iter.hasNext() && !present) {
            if ((StudentCourse)iter.next() == childObject) {
                present = true;
            }
        }
        return present;
    }

    /**
     * Make a connection from a parent <code>Course</code> to a child <code>StudentCourse</code>.
     *
     * @param parentObject The <code>Course</code> who is owner in the association
     * @param childObject The <code>StudentCourse</code> who is member in the association
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void connectFromParent(Course parentObject,StudentCourse childObject,Session session) {
        if (parentObject != null && childObject != null && !isChildPresent(parentObject,childObject,session)) {
            parentObject.getStudentCourses().add(childObject);
        }
    }
    /**
     * Disconnect a child <code>StudentCourse</code> from its parent <code>Course</code>.
     *
     * @param parentObject The <code>Course</code> who is owner in the association
     * @param childObject The <code>StudentCourse</code> who is member in the association
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void disconnectFromParent(Course parentObject,StudentCourse childObject,Session session) {
        if (parentObject != null && childObject != null && isChildPresent(parentObject,childObject,session)) {
            parentObject.getStudentCourses().remove(childObject);
        }
    }

    /**
     * For a <code>StudentCourse</code> object set the association from its children to the object
     * This setting is done only for children who are owner of the association between the child and this <code>StudentCourse</code>,
     * and only if the association is navigable from the child to its parent.
     *
     * @param parentObject The parent <code>StudentCourse</code> object
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void connectFromUpRelated(StudentCourse parentObject, Session session) {
        if (!getCurrentObjectSelection().getDoOneRelated()) return;
        if (parentObject != null) {
            Iterator iter;
            Object childObject;
            boolean found;
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            childObject = parentObject.getStudent();
            if (childObject != null) {
                dataService.findAssociated(((Student)childObject).getStudentCourses(),session);
                found = false;
                if (((Student)childObject).getStudentCourses() == null) {
                    Set<StudentCourse> tmp = TypeTool.getDefaultSet();
                    ((Student)childObject).setStudentCourses(tmp);
                }
                iter = ((Student)childObject).getStudentCourses().iterator();
                while (iter.hasNext()) {
                    if ((StudentCourse)(iter.next()) == parentObject) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    ((Student)childObject).getStudentCourses().add(parentObject);
                }
            }
        }
    }


    /**
     * Load all instances of this role
     *
     * @param dbParentObject
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void loadAll(Course dbParentObject,Session session) {
        if (dbParentObject != null) {
            Iterator iter;
            iter = dbParentObject.getStudentCourses() != null ?
                       dbParentObject.getStudentCourses().iterator() :
                       null;
            if (iter != null) {
                while (iter.hasNext()) {
                    StudentCourse object = (StudentCourse)(iter.next());
                    loadRelated(object,session);
                }
            }
        }
    }

    /**
     * Make sure that all related objects to a <code>StudentCourse</code> object are loaded.
     *
     * @param object The <code>StudentCourse</code> object
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    final void loadRelated(StudentCourse object,Session session) {
        if (object != null) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            if ((getCurrentObjectSelection().getDoOneRelated())) {
                dataService.findAssociated(object.getStudent(),session);
            }
        }
    }

    /**
     * Get current object from the result
     * This method is only when this role is above the target role, i.e. it assumes that there
     * is only one member in each collection from the root to this object
     *
     * @param rootResult The Object which is top node in the result
     */
    StudentCourse getCurrentObject(Object rootResult) {
        StudentCourse thisObject = null;
        if (getParent() != null) {
            Course parentObject = ((CourseDefaultManager)getParent()).getCurrentObject(rootResult);
            if (parentObject != null) {
                Collection collection = parentObject.getStudentCourses();
                if (collection != null) {
                   Iterator iter = collection.iterator();
                   if (iter.hasNext()) thisObject = (StudentCourse)(iter.next());
                }
            }
        }
        return thisObject;
    }

    /**
     * Do cleanup of result before sending it to the client. The cleanup will remove unneeded objects
     * to reduce the datatransfer between the server and the client.
     * This method is the entrypoint for cleanup after an insert/update/save with this role as target.
     * For each result root object in the result it will use cleanupAsTarget to remove unneeded objects.
     *
     * @param rootResult The Object who is the top of the path to target
     */
    public void cleanupResult(Object rootResult) {
        if (rootResult instanceof Collection) {
            Iterator iter = ((Collection)rootResult).iterator();
            while (iter.hasNext()) {
                cleanupResultAsTarget((Object)iter.next());
            }
        }
        else
        {
            cleanupResultAsTarget(rootResult);
        }
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for one result root object. For objects on the path to target it will remove
     * all downrelated children, but it will keep any uprelated children. For the target node itself it will
     * only keep those objects actually updated.
     *
     * @param rootResult The object which is the top of the path to target
     */
    public void cleanupResultAsTarget(Object rootResult) {
        if (hookCleanupResultAsTargetStart(rootResult)) {
            if (getParent() == null) {
                Role role;
                role = findRole("student");
                if (role != null) {
                    ((StudentDefaultManager)role).cleanupResultAsChild((StudentCourse)rootResult);
                }
            }
            else {
                StudentCourse thisObject = null;
                Course parentObject = ((CourseDefaultManager)getParent()).cleanupResultAsParent(rootResult,"studentCourses");
                if (parentObject != null) {
                    Collection children = (Collection)resultMap.get(parentObject);
                    if (children == null) {
                        children = TypeTool.getDefaultSet();
                    }
                    parentObject.setStudentCourses((Set)children);
                    Iterator iter = children.iterator();
                    while (iter.hasNext()) {
                        thisObject = (StudentCourse)iter.next();
                        Role role;
                        role = findRole("student");
                        if (role != null) {
                            ((StudentDefaultManager)role).cleanupResultAsChild(thisObject);
                        }
                    }
                }
            }
        }
        hookCleanupResultAsTargetEnd(rootResult);
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for all  objects on the path to target object.
     *
     * @param rootResult The Object who is the top of the path to target
     * @param childRoleName The name of the child role calling this method
     *
     * @return the cleaned object
     */
    public StudentCourse cleanupResultAsParent(Object rootResult,String childRoleName) {
        StudentCourse thisObject = hookCleanupResultAsParentStart(rootResult,childRoleName);
        if (thisObject == null) {
            if (getParent() == null) {
                thisObject = (StudentCourse)rootResult;
                if (thisObject != null) {
                    Role role;
                }
            }
            else {
                thisObject = null;
                Course parentObject = ((CourseDefaultManager)getParent()).cleanupResultAsParent(rootResult,"studentCourses");
                if (parentObject != null) {
                    Role role;
                    Collection children = (Collection)resultMap.get(parentObject);
                    if (children == null) {
                        children = TypeTool.getDefaultSet();
                    }
                    parentObject.setStudentCourses((Set)children);
                    Iterator iter = children.iterator();
                    while (iter.hasNext()) {
                        thisObject = (StudentCourse)iter.next();
                    }
                }
            }
        }
        hookCleanupResultAsParentEnd(thisObject,childRoleName);
        return thisObject;
    }

    /**
     * Do cleanup of result before sending it to the client.
     * This method is for all related objects below the the target object in the object selction.
     *
     * @param parentObject The <code>Course</code> object who is parent to the objects processed. 
     */
    public void cleanupResultAsChild(Course parentObject) {
        if (hookCleanupResultAsChildStart(parentObject)) {
            if ((getCurrentObjectSelection().getDoFirstLevelManyRelated())) {
                getCurrentObjectSelection().setDoFirstLevelManyRelated(getCurrentObjectSelection().getDoAnyLevelManyRelated());
                if (parentObject != null) {
                    parentObject.setStudentCourses((Set)(resultMap.get(parentObject)));
                    StudentCourse thisObject;
                    Role role;
                    Collection children = parentObject.getStudentCourses();
                    if (children == null) {
                        children = TypeTool.getDefaultSet();
                    }
                    Iterator iter = children.iterator();
                    while (iter.hasNext()) {
                    thisObject = (StudentCourse)iter.next();
                        role = findRole("student");
                        if (role != null) {
                            ((StudentDefaultManager)role).cleanupResultAsChild(thisObject);
                        }
                    }
                }
                getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
            } else {
                parentObject.setStudentCourses(null);
            }
        }
        hookCleanupResultAsChildEnd(parentObject);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and searches for a target object of class <code>StudentCourse</code>.
     * <p>
     * Find is not an allowed action for role <code>studentCourses</code>
     * <p>
     *
     * @param objectSelection The object selection with all search criteria.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object find(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Object rootObject = null;
        List rootList = new LinkedList();
        StudentCourse resultObject = null;
        StudentCourse targetObject = null;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            if (iter.hasNext()) {
                targetObject = (StudentCourse)iter.next();
            }
        }
        resultObject = hookFindStart(objectSelection,targetObject,ctx,session);
        if (resultObject == null) {
            Course parentObject = null;
            if (getParent() != null) {
                parentObject = findParentObject(objectSelection);
                if (targetObject != null) {
                    targetObject.setCourse(parentObject);
                }
            }
            resultObject = findSingle(targetObject,objectSelection.getTargetMainKey(),objectSelection.getFindData(),ctx,session);
            if (resultObject != null) {
                findUpRelated(resultObject,ctx,session);
            } 
            if (parentObject != null) {
                if (targetObject != null) {
                    parentObject.getStudentCourses().remove(targetObject);
                }
                parentObject.getStudentCourses().add(resultObject);
            }
            if (getParent() == null) {
                if (resultObject != null) {
                    rootList.add(resultObject);
                }
            }
            else {
                rootObject = findRootObject(objectSelection);
                rootList.add(rootObject);
            }
            hookFindEnd(objectSelection,resultObject,ctx,session);
        }
        return rootList;
    }

    /**
     * Find a single <code>StudentCourse</code> object in the database.
     * <p>
     * The method uses the search criteria defined in the <code>findData</code> parameter. Without any <code>findData</code>,
     * the method uses the targetKey to find the <code>StudentCourse</code> object. The targetKey must be a unique attribute or group.
     * Without any targetKey the main key is chosen as the first unique key found where the all attributes are part of the
     * object selection. The unique keys are examined in the following sequence:
     * <ul>
     *     <li> The primary key
     *     <li> Attributes specified as unique
     *     <li> Groups specified as unique
     * </ul>
     *
     * @param targetObject The target <code>StudentCourse</code> object with the key attributes.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object found.
     */
    public StudentCourse findSingle(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        StudentCourse resultObject = hookFindSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            Class clazz = StudentCourse.class;
            List keyAttributes = null;
            String primaryKey = getPrimaryKey();
            if (targetKey != null) {
                keyAttributes = getKeyAttributes(targetKey);
                if (primaryKey != null && !(primaryKey.equals(targetKey))) {
                    primaryKey = null;
                }
            }
            else {
                keyAttributes = getKeyAttributes(primaryKey != null ? primaryKey : getMainKey());
            }
            if (primaryKey == null && keyAttributes == null && findData == null) {
                Object[] args = { "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NO_KEY_DEFINED, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            if (findData != null || targetObject != null) {
                if (primaryKey != null) {
                    Serializable keyObject;
                    if (primaryKey.equals("id")) {

                        keyObject = targetObject != null ? (Serializable)TypeTool.toObject(targetObject.getId()) : null;
                        if (keyObject != null || findData != null) {
                            resultObject = (StudentCourse)dataService.find(clazz,keyObject,findData,session);
                        }
                    }
                    else {
                        resultObject = (StudentCourse)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                    }
                }
                else {
                    resultObject = (StudentCourse)dataService.find(clazz,targetObject,keyAttributes,findData,session);
                }
            }
        }
        if (!hookFindSingleEnd(resultObject,ctx,session)) {
            resultObject = null;
        }
        return resultObject;
    }

    /**
     * From a <code>StudentCourse</code> object find all up related objects of this role.
     * <p>
     * An up related object to an object/role in the object selction is an object connected to its parent object
     * in the object selction thru an association where the parent object is the member object in the association and the
     * object itself is the owner object in the association.
     *
     * @param object The database object to find all up related from.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void findUpRelated(StudentCourse object, ClientContext ctx, Session session) {
        if (hookFindUpRelatedStart(object,ctx,session)) {
            if (object != null) {
                Role role;
                if (getCurrentObjectSelection().getDoOneRelated()) {
                    role = findRole("student");
                    ((StudentDefaultManager)role).findAsRelated(object,ctx,session);
                } else {
                    object.setStudent(null);
                }
            }
        }
        hookFindUpRelatedEnd(object,ctx,session);
    }

    /**
     * From a parent <code>Course</code> object find all related objects of the role <code>studentCourses</code>.
     *
     * @param parentObject The <code>Course</code> object.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void findAsRelated(Course parentObject, ClientContext ctx, Session session) {
        if (hookFindAsRelatedStart(parentObject,ctx,session)) {
            if (parentObject != null) {
                DataService dataService = DataServiceImpl.getDataServiceImpl();
                dataService.findAssociated(parentObject.getStudentCourses(),session);
                StudentCourse childObject = null;
                Iterator iter = parentObject.getStudentCourses() != null ?
                                    parentObject.getStudentCourses().iterator() :
                                    null;
                while (iter != null && iter.hasNext()) {
                    childObject = (StudentCourse)iter.next();
                    findUpRelated(childObject,ctx,session);
                }
            }
        }
        hookFindAsRelatedEnd(parentObject,ctx,session);
    }
    /**
     * This method is part of the <code>Manager</code> Interface and finds all target objects of class <code>StudentCourse</code>.
     * <p>
     * The method uses the search criteria defined in <code>objectSelection.findData</code>. Without any <code>findData</code>,
     * the method will return all occurences of <code>StudentCourse</code>. Each <code>StudentCourse</code> object
     * returned will also contain all uprelated child objects. 
     *
     * @param objectSelection The object selection
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return List of <code>StudentCourse</code> objects found.
     */
    public List<?> findAll(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        if (objectSelection.getFindData() != null && (objectSelection.getFindData().getDeepFindAll())) {
            objectSelection.setDoOneRelated(true);
            objectSelection.setDoFirstLevelManyRelated(true);
            objectSelection.setDoAnyLevelManyRelated(true);
        }
        List resultList = null;
        Class clazz = StudentCourse.class;
        resultList = hookFindAllStart(clazz,objectSelection.getFindData(),ctx,session);
        if (resultList == null) {
            StudentCourse targetObject = null;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                if (iter.hasNext()) {
                    targetObject = (StudentCourse)iter.next();
                }
            }
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            resultList = dataService.findAll(clazz,targetObject,objectSelection.getFindData(),session);
            if (resultList != null) {
                StudentCourse object;
                Iterator iter = resultList.iterator();
                while (iter.hasNext()) {
                    object = (StudentCourse)iter.next();
                    findUpRelated(object,ctx,session);
                }
            }
        }
        hookFindAllEnd(resultList,ctx,session);
        return resultList;
    }

    /**
     * This method is part of the <code>Manager</code> Interface and saves a target object of class <code>StudentCourse</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object save(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Course clientParentObject = null;
        Course dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Course)findParentObject(objectSelection);
            if (clientParentObject != null)
            {
                dbParentObject = ((CourseDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        StudentCourse resultObject = null;
        StudentCourse targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (StudentCourse)iter.next();
                ActionType action = ActionType.SAVE;
                if (objectSelection.getActions() != null) {
                    action = (ActionType)(objectSelection.getActions().get(targetObject));
                    if (action == null) action = ActionType.SAVE;
                }
                switch (action) {
                    case SAVE:
                        resultObject = save(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case INSERT:
                        resultObject = insert(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case UPDATE:
                        resultObject = update(targetObject, clientParentObject, dbParentObject, ctx, session);
                        break;
                    case DELETE:
                        delete(targetObject, clientParentObject, dbParentObject, ctx, session);
                        resultObject = null;
                        break;
                    case CONNECT:
                        if (getParent() != null) {
                            resultObject = connect(targetObject, clientParentObject, dbParentObject, ctx, session);
                        }
                        break;
                    case DISCONNECT:
                        if (getParent() != null) {
                            disconnect(targetObject, clientParentObject, dbParentObject, ctx, session);
                        }
                        resultObject = null;
                        break;
                    default:
                    {
                        Object[] args = { action.name() };
                        Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UNKNOWN_SERVICE_ACTION, args);
                        MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                        throw new GenovaServiceException(msg);
                    }
                }
                if (resultObject != null) {
                    if (getParent() == null) {
                        rootList.add(resultObject);
                    } else {
                        resultSet.add(resultObject);
                    }
                }
            }
        }
        if (getParent() != null) {
            if (objectSelection.getActions() == null && objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Save one <code>StudentCourse</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the database.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param clientParentObject The <code>Course</code> object as sent from the client.
     * @param dbParentObject The <code>Course</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as updated/inserted into the database.
     */
    public StudentCourse save(StudentCourse targetObject, Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        StudentCourse resultObject;
        resultObject = hookSaveStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            if (getParent() != null) {
                targetObject.setCourse(dbParentObject);
            }
            saveUpRelated(targetObject,setsContainAllRelated,ctx,session);
            resultObject = saveSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultObject,session);
                }
            }
            connectFromUpRelated(resultObject,session);
        }
        hookSaveEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Save a single <code>StudentCourse</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database, a new occurence will be inserted into the databse.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as updated/inserted into the database.
     */
    public StudentCourse saveSingle(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        StudentCourse resultObject = null;
        resultObject = hookSaveSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                resultObject = updateSingle(targetObject,targetKey,findData,ctx,session);
            }
            else {
                resultObject = insertSingle(targetObject,targetKey,findData,ctx,session);
            }
        }
        hookSaveSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>StudentCourse</code> object save all its up related objects
     * <p>
     * The action called for each child role depends on thats role legal function specification in the object selection.
     *
     * @param object The <code>StudentCourse</code> object with it's child objects as recieved from the client.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void saveUpRelated(StudentCourse object, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        if (hookSaveUpRelatedStart(object,ctx,session)) {
            if (object != null && getCurrentObjectSelection().getDoOneRelated()) {
                Role role;
                role = findRole("student");
                ((StudentDefaultManager)role).saveAsRelated(object,setsContainAllRelated,ctx,session);
            }
        }
        hookSaveUpRelatedEnd(object,ctx,session);
    }

    /**
     * From a <code>Course</code> object save all related <code>StudentCourse</code> objects.
     * <p>
     * The method will try to insert occurences from the client object not present in the database object,
     * update occurences present in both the client object and the database object and it will try to delete
     * object present in the database object but not present in the client object.
     *
     * @param clientParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as recieved from the client.
     * @param dbParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void saveAsRelated(Course clientParentObject, Course dbParentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        if (hookSaveAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            StudentCourse childObject;
            StudentCourse resultChildObject;
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getStudentCourses() != null ?
                                clientParentObject.getStudentCourses().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (StudentCourse)iter.next();
                childObject.setCourse(dbParentObject);
                saveUpRelated(childObject,setsContainAllRelated,ctx,session);
                resultChildObject = saveSingle(childObject,null,null,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
                connectFromUpRelated(resultChildObject,session);
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookSaveAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * Save a <code>StudentCourse</code> object of this role as a parent.
     * <p>
     * Saving an object as a parent, will also try to save the objects up related child objects.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param object The <code>StudentCourse</code> object as sent from the client.
     * @param root The array will contain the root object at return
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as updated/inserted/identified in the database.
     */
    public StudentCourse saveAsParent(ObjectSelection objectSelection, StudentCourse object, Object root[], ClientContext ctx,Session session) {
        StudentCourse resultObject = null;
        resultObject = hookSaveAsParentStart(objectSelection,object,ctx,session);
        if (resultObject == null) {
            if (object != null) {
                Set resultSet = TypeTool.getDefaultSet();
                Course clientParentObject = null;
                Course dbParentObject = null;
                if (getParent() != null) {
                    clientParentObject = (Course)findParentObject(objectSelection);
                    if (clientParentObject != null)
                    {
                        dbParentObject = ((CourseDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,root,ctx,session);
                        if (dbParentObject == null) {
                            Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                            Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                            MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                            throw new GenovaServiceException(msg);
                        }
                        object.setCourse(dbParentObject);
                        resultMap.put(dbParentObject,resultSet);
                    }
                    else {
                        Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                        Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                        MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                        throw new GenovaServiceException(msg);
                    }
                }
                saveUpRelatedAsParent(object,ctx,session);
                if (getCurrentObjectSelection().getDoParents()) {
                    resultObject = saveSingle(object,null,null,ctx,session);
                } else {
                    resultObject = identifySingle(object,ctx,session);
                }
                if (getParent() != null) {
                    resultSet.add(resultObject);
                }
            }
        }
        if (getParent() == null) {
            root[0] = resultObject;
        }
        hookSaveAsParentEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Save all uprelated <code>StudentCourse</code> child objects of this role as an uprelated parent.
     * <p>
     * This save will recursive save upreladed children, but it will not save any of theirs downrelated children.
     *
     * @param clientObject The <code>StudentCourse</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void saveUpRelatedAsParent(StudentCourse clientObject, ClientContext ctx,Session session) {
        if (hookSaveUpRelatedAsParentStart(clientObject,ctx,session)) {
            if (clientObject != null) {
                Role role;
                Object clientChildObject;
                Object dbChildObject;
                role = findRole("student");
                clientChildObject = clientObject.getStudent();
                if (clientChildObject != null) {
                    if (getCurrentObjectSelection().getDoParents()) {
                        dbChildObject = ((StudentDefaultManager)role).saveSingle((Student)clientChildObject,null,null,ctx,session);
                    } else {
                        dbChildObject = ((StudentDefaultManager)role).identifySingle((Student)clientChildObject,ctx,session);
                    }
                    if (dbChildObject != null) {
                        clientObject.setStudent((Student)dbChildObject);
                    }
                }
            }
        }
        hookSaveUpRelatedAsParentEnd(clientObject,ctx,session);
    }

    /**
     * Identify a single <code>StudentCourse</code> object in the database.
     * <p>
     * If the target object does not exist in the database an exception in thrown.
     *
     * @param object The <code>StudentCourse</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as it is in the database.
     */
    public StudentCourse identifySingle(StudentCourse object,ClientContext ctx,Session session)
    {
        StudentCourse resultObject = hookIdentifySingleStart(object,ctx,session);
        if (resultObject == null) {
            resultObject = (StudentCourse)cloneObject(object);
            resultObject = findSingle(resultObject,null,null,ctx,session);
            if (resultObject == null) {
                Object[] args = { "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_IDENTIFY_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookIdentifySingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>Course</code> object identify all related <code>StudentCourse</code> objects.
     * <p>
     * The method will try to identify all occurences present in the client object 
     * and it will try to delete objects present in the database object but not present in the client object.
     * An exception in thrown if an object in the client object is not present in the database object.
     *
     * @param clientParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as recieved from the client.
     * @param dbParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void identifyAsRelated(Course clientParentObject, Course dbParentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        StudentCourse childObject;
        StudentCourse resultChildObject;
        if (hookIdentifyAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getStudentCourses() != null ?
                                clientParentObject.getStudentCourses().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (StudentCourse)iter.next();
                childObject.setCourse(dbParentObject);
                saveUpRelated(childObject,setsContainAllRelated,ctx,session);
                resultChildObject = identifySingle(childObject,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
                connectFromUpRelated(resultChildObject,session);
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookIdentifyAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and inserts a target object of class <code>StudentCourse</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object insert(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Course clientParentObject = null;
        Course dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Course)findParentObject(objectSelection);
            if (clientParentObject != null)
            {
                dbParentObject = ((CourseDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        StudentCourse resultObject = null;
        StudentCourse targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (StudentCourse)iter.next();
                resultObject = insert(targetObject, clientParentObject, dbParentObject, ctx, session);
                if (getParent() == null) {
                    rootList.add(resultObject);
                } else {
                    resultSet.add(resultObject);
                }
            }
        }
        if (getParent() != null) {
            if (objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Insert one <code>StudentCourse</code> object and its related objects.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param clientParentObject The <code>Course</code> object as sent from the client.
     * @param dbParentObject The <code>Course</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as inserted into the database.
     */
    StudentCourse insert(StudentCourse targetObject, Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        StudentCourse resultObject;
        resultObject = hookInsertStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            if (getParent() != null) {
                targetObject.setCourse(dbParentObject);
            }
            saveUpRelated(targetObject,setsContainAllRelated,ctx,session);
            resultObject = insertSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultObject,session);
                }
            }
            connectFromUpRelated(resultObject,session);
        }
        hookInsertEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Insert a single <code>StudentCourse</code> object into the database.
     * <p>
     * If the target object does not exists, the object will be inserted in the database. If the target
     * object does exist in the database an exception in thrown.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as updated into the database.
     */
    public StudentCourse insertSingle(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        StudentCourse resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
        if (!isIdentical(targetObject,resultObject)) {
            StudentCourse tmpObject = hookInsertSingleStart(targetObject,targetKey,findData,ctx,session);
            if (tmpObject == null) {
                if (resultObject == null) {
                    resultObject = cloneObject(targetObject);
                    DomainUtil.setLockFlag(resultObject,null);
                    DataService dataService = DataServiceImpl.getDataServiceImpl();
                    dataService.insert(resultObject,session); 
                }
                else {
                    Object[] args = { "StudentCourse", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_INSERT_ON_EXISTING, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
            }
            else {
              resultObject = tmpObject;
            }
            TriggerInvoker.invoke(resultObject,TriggerType.INSERT, getCurrentObjectSelection().getTargetRoleName().equals("studentCourses"), ctx, session);
            hookInsertSingleEnd(resultObject,ctx,session);
        }
        return resultObject;
    }

    /**
     * From a <code>Course</code> object insert all related <code>StudentCourse</code> objects.
     * <p>
     * The method will try to insert occurences present in the client object
     * and it will try to delete objects present in the database object but not present in the client object.
     * An exception in thrown if an object in the client object is present in the database object.
     *
     * @param clientParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as recieved from the client.
     * @param dbParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void insertAsRelated(Course clientParentObject, Course dbParentObject, boolean setsContainAllRelated,ClientContext ctx, Session session) {
        if (hookInsertAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            StudentCourse childObject;
            StudentCourse resultChildObject;
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getStudentCourses() != null ?
                                clientParentObject.getStudentCourses().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (StudentCourse)iter.next();
                childObject.setCourse(dbParentObject);
                saveUpRelated(childObject,setsContainAllRelated,ctx,session);
                resultChildObject = insertSingle(childObject,null,null,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
                connectFromUpRelated(resultChildObject,session);
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookInsertAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and updates a target object of class <code>StudentCourse</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object update(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Course clientParentObject = null;
        Course dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Course)findParentObject(objectSelection);
            if (clientParentObject != null)
            {
                dbParentObject = ((CourseDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        StudentCourse resultObject = null;
        StudentCourse targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (StudentCourse)iter.next();
                resultObject = update(targetObject, clientParentObject, dbParentObject, ctx, session);
                if (getParent() == null) {
                    rootList.add(resultObject);
                } else {
                    resultSet.add(resultObject);
                }
            }
        }
        if (getParent() != null) {
            if (objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Update one <code>StudentCourse</code> object and its related objects.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param clientParentObject The <code>Course</code> object as sent from the client.
     * @param dbParentObject The <code>Course</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as updated in the database.
     */
    StudentCourse update(StudentCourse targetObject, Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        boolean setsContainAllRelated = getCurrentObjectSelection().getSetsContainAllRelated();
        StudentCourse resultObject;
        resultObject = hookUpdateStart(getCurrentObjectSelection(),targetObject,ctx,session);
        if (resultObject == null) {
            if (getParent() != null) {
                targetObject.setCourse(dbParentObject);
            }
            saveUpRelated(targetObject,setsContainAllRelated,ctx,session);
            resultObject = updateSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultObject,session);
                }
            }
            connectFromUpRelated(resultObject,session);
        }
        hookUpdateEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }


    /**
     * Update a single <code>StudentCourse</code> object in the database.
     * <p>
     * If the target object already exists, the object will be updated in the database. If the target
     * object does not exist in the database an exception in thrown.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param targetKey The key to use.
     * @param findData The findData to use. The findData is just passed to the dataaccess layer
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return The <code>StudentCourse</code> object as updated into the database.
     */
    public StudentCourse updateSingle(StudentCourse targetObject, String targetKey, FindData findData, ClientContext ctx, Session session) {
        StudentCourse resultObject = null;
        resultObject = hookUpdateSingleStart(targetObject,targetKey,findData,ctx,session);
        if (resultObject == null) {
            resultObject = findSingle(targetObject,targetKey,findData,ctx,session);
            if (resultObject != null) {
                if (!isIdentical(targetObject,resultObject)) {
                    if (DomainUtil.hasLockFlag(resultObject)) {
                        Serializable targetFlag = DomainUtil.getLockFlag(targetObject);
                        Serializable resultFlag = DomainUtil.getLockFlag(resultObject);
                        if (targetFlag == null || (!(DomainUtil.equalsLockFlag(targetFlag,resultFlag)))) {
                            Object[] args = { "StudentCourse" };
                            Message msg = MessageSystem.getMessageFactory().getMessage(targetFlag == null ? CRuntimeMsg.SM_NO_LOCKFLAG_VALUE : CRuntimeMsg.SM_UPDATED_BY_ANOTHER_USER, args);
                            MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                            throw new GenovaServiceException(msg);
                        }
                   }
                   copyAttributes(targetObject,resultObject,true);
                   copyRelatedOwners(targetObject,resultObject);
                }
                TriggerInvoker.invoke(resultObject,TriggerType.UPDATE, getCurrentObjectSelection().getTargetRoleName().equals("studentCourses"), ctx, session);
            }
            else {
                Object[] args = { "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_UPDATE_ON_NONEXISTING, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        hookUpdateSingleEnd(resultObject,ctx,session);
        return resultObject;
    }

    /**
     * From a <code>Course</code> object update all related <code>StudentCourse</code> objects.
     * <p>
     * The method will try to update occurences present in both the client object and the database object
     * and it will try to delete object present in the database object but not present in the client object.
     * An exception in thrown if an object in the client object is not present in the database object.
     *
     * @param clientParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as recieved from the client.
     * @param dbParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as it is in the database.
     * @param setsContainAllRelated Is true if operation in set mode
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void updateAsRelated(Course clientParentObject, Course dbParentObject, boolean setsContainAllRelated, ClientContext ctx, Session session) {
        StudentCourse childObject;
        StudentCourse resultChildObject;
        if (hookUpdateAsRelatedStart(clientParentObject,dbParentObject,ctx,session)) {
            Set resultSet = TypeTool.getDefaultSet();
            resultMap.put(dbParentObject,resultSet);
            Iterator iter = clientParentObject.getStudentCourses() != null ?
                                clientParentObject.getStudentCourses().iterator() :
                                null;
            while (iter != null && iter.hasNext()) {
                childObject = (StudentCourse)iter.next();
                childObject.setCourse(dbParentObject);
                saveUpRelated(childObject,setsContainAllRelated,ctx,session);
                resultChildObject = updateSingle(childObject,null,null,ctx,session);
                resultSet.add(resultChildObject);
                if (dbParentObject != null) {
                    connectFromParent(dbParentObject,resultChildObject,session);
                }
                connectFromUpRelated(resultChildObject,session);
            }
            if (setsContainAllRelated) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
        }
        hookUpdateAsRelatedEnd(clientParentObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and deletes a target object of class <code>StudentCourse</code>.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object delete(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Course clientParentObject = null;
        Course dbParentObject = null;
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Course)findParentObject(objectSelection);
            dbParentObject = null;
            if (clientParentObject != null)
            {
                dbParentObject = ((CourseDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
        }
        List rootList = new LinkedList();
        StudentCourse targetObject;
        Collection targetObjects = null;
        targetObjects = (Collection)findTargetObject(objectSelection);
        if (targetObjects != null) {
            Iterator iter = targetObjects.iterator();
            while (iter.hasNext()) {
                targetObject = (StudentCourse)iter.next();
                delete(targetObject,clientParentObject,dbParentObject,ctx,session);
            }
        }
        if (getParent() != null) {
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Delete a single <code>StudentCourse</code> object and all it's related objects in the database.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param clientParentObject The <code>Course</code> object as sent from the client.
     * @param dbParentObject The <code>Course</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void delete(StudentCourse targetObject,Course clientParentObject,Course dbParentObject,ClientContext ctx,Session session) {
        StudentCourse resultObject = null;
        if (hookDeleteStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            if (getParent() != null) {
                targetObject.setCourse(dbParentObject);
            }
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            deleteRelated(resultObject,ctx,session);
            deleteSingle(resultObject,ctx,session);
            if (getParent() != null) {
                if (dbParentObject != null) {
                    loadAll(dbParentObject,session);
                    dbParentObject.getStudentCourses().remove(resultObject);
                }
            }
        }
        hookDeleteEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Delete a single <code>StudentCourse</code> object in the database.
     *
     * @param object The <code>StudentCourse</code> object as sent from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteSingle(StudentCourse object,ClientContext ctx,Session session) {
        if (hookDeleteSingleStart(object,ctx,session)) {
            DataService dataService = DataServiceImpl.getDataServiceImpl();
            dataService.delete(object,session);
            TriggerInvoker.invoke(object,TriggerType.DELETE, getCurrentObjectSelection().getTargetRoleName().equals("studentCourses"), ctx, session);
        }
        hookDeleteSingleEnd(ctx,session);
    }
    /**
     * From a <code>StudentCourse</code> object delete all its related objects
     * <p>
     * The action called for each child role depends on thats role legal function specification in the object selection.
     *
     * @param object The <code>StudentCourse</code> object with it's child objects as recieved from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteRelated(StudentCourse object, ClientContext ctx, Session session) {
        Role childRole;
        if (hookDeleteRelatedStart(object,ctx,session)) {
            if (getCurrentObjectSelection().getDoOneRelated()) {
                childRole = findRole("student");
                if (childRole != null) {
                    ((StudentDefaultManager)childRole).deleteAsRelated(object,ctx,session);
                }
            }
        }
        hookDeleteRelatedEnd(object,ctx,session);
    }

    /**
     * From a <code>Course</code> object delete all related <code>StudentCourse</code> objects.
     * This role is a member in the association to the parent.
     *
     * @param parentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as it is in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteAsRelated(Course parentObject, ClientContext ctx, Session session) {
        StudentCourse childObject;
        if (hookDeleteAsRelatedStart(parentObject,ctx,session)) {
            if (parentObject != null) {
                Iterator iter = parentObject.getStudentCourses() != null ? 
                                parentObject.getStudentCourses().iterator() :
                                null;
                while (iter != null && iter.hasNext()) {
                    childObject = (StudentCourse)iter.next();
                    deleteRelated(childObject,ctx,session);
                    deleteSingle(childObject,ctx,session);
                    iter.remove();
                }
            }
        }
        hookDeleteAsRelatedEnd(parentObject,ctx,session);
    }

    /**
     * From a <code>Course</code> object delete related <code>StudentCourse</code> objects that is present in the database but not in the client.
     *
     * @param clientParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as it is recived from the client
     * @param dbParentObject The <code>Course</code> object with it's child <code>StudentCourse</code> objects as it is in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void deleteAsRelated(Course clientParentObject, Course dbParentObject, ClientContext ctx, Session session) {
        if (clientParentObject != null && dbParentObject != null) {
            Iterator iterDb = dbParentObject.getStudentCourses() != null ?
                                  dbParentObject.getStudentCourses().iterator() :
                                  null;
            StudentCourse dbChildObject;
            while (iterDb != null && iterDb.hasNext()) {
              boolean found = false;
              dbChildObject = (StudentCourse)(iterDb.next());
              Iterator iterClient = clientParentObject.getStudentCourses() != null ?
                                        clientParentObject.getStudentCourses().iterator() :
                                        null;
              while (iterClient != null && iterClient.hasNext()) {
                  if (dbChildObject.equals(iterClient.next())) {
                      found = true;
                      break;
                  }
              }
              if (!found) {
                deleteRelated(dbChildObject,ctx,session);
                deleteSingle(dbChildObject,ctx,session);
                iterDb.remove();
            }
          }
        }
    }

    /**
     * This method is part of the <code>Manager</code> Interface and connects a target object of class <code>StudentCourse</code> to its parent node <code>Course.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object connect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Course clientParentObject = null;
        Course dbParentObject = null;
        List rootList = new LinkedList();
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Course)findParentObject(objectSelection);
            dbParentObject = null;
            if (clientParentObject != null)
            {
                dbParentObject = ((CourseDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            StudentCourse targetObject;
            StudentCourse resultObject;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                while (iter.hasNext()) {
                    targetObject = (StudentCourse)iter.next();
                    resultObject = connect(targetObject,clientParentObject,dbParentObject,ctx,session);
                    resultSet.add(resultObject);
                }
            }
            if (objectSelection.getSetsContainAllRelated()) {
                deleteAsRelated(clientParentObject,dbParentObject,ctx,session);
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Connect a single <code>StudentCourse</code> object to its parent <code>Course object.
     * The object will be disconnected from its parent object before it is connected to its new parent object.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param clientParentObject The <code>Course</code> object as sent from the client.
     * @param dbParentObject The <code>Course</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public StudentCourse connect(StudentCourse targetObject,Course clientParentObject,Course dbParentObject,ClientContext ctx,Session session) {
        StudentCourse resultObject = null;
        if (hookConnectStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            if (resultObject != null) {
                Course oldParent = resultObject.getCourse();
                if (oldParent != null) {
                    disconnectSingle(resultObject,oldParent,ctx,session);
                }
            }
            connectSingle(resultObject,dbParentObject,ctx,session);
        }
        hookConnectEnd(getCurrentObjectSelection(),resultObject,ctx,session);
        return resultObject;
    }

    /**
     * Connect a single <code>StudentCourse</code> object from its parent Course in the database.
     *
     * @param dbChildObject The <code>StudentCourse</code> object as found in the database
     * @param dbParentObject The <code>Course</code> object as found in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void connectSingle(StudentCourse dbChildObject,Course dbParentObject,ClientContext ctx,Session session) {
        if (hookConnectSingleStart(dbChildObject,dbParentObject,ctx,session)) {
            if (dbParentObject != null && dbChildObject != null) {
                dbChildObject.setCourse(dbParentObject);
                dbParentObject.getStudentCourses().add(dbChildObject);
            }
        }
        hookConnectSingleEnd(dbChildObject,dbParentObject,ctx,session);
    }

    /**
     * This method is part of the <code>Manager</code> Interface and disconnects a target object of class <code>StudentCourse</code> from its parent node <code>Course.
     *
     * @param objectSelection The object selection with all data from the client.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     * @return List containing the object selection root object to the target object, with all its related objects.
     */
    public Object disconnect(ObjectSelection objectSelection, ClientContext ctx, Session session) {
        if (getCurrentObjectSelection().getDoAnyLevelManyRelated()) {
            getCurrentObjectSelection().setDoFirstLevelManyRelated(true);
        }
        Set resultSet = TypeTool.getDefaultSet();
        Object[] rootObject = new Object[1];
        Course clientParentObject = null;
        Course dbParentObject = null;
        List rootList = new LinkedList();
        if (getParent() != null) {
            rootObject[0] = findRootObject(objectSelection);
            clientParentObject = (Course)findParentObject(objectSelection);
            dbParentObject = null;
            if (clientParentObject != null)
            {
                dbParentObject = ((CourseDefaultManager)getParent()).saveAsParent(objectSelection,clientParentObject,rootObject,ctx,session);
                if (dbParentObject == null) {
                    Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                    Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                    MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                    throw new GenovaServiceException(msg);
                }
                resultMap.put(dbParentObject,resultSet);
            }
            else {
                Object[] args = { "Course", "StudentCourse", "AddStudentsToCourse_os" };
                Message msg = MessageSystem.getMessageFactory().getMessage(CRuntimeMsg.SM_NONEXISTING_PARENT, args);
                MessageSystem.getMessageDispatcher(MessageSystem.NO_INTERACTION).dispatch(msg);
                throw new GenovaServiceException(msg);
            }
            StudentCourse targetObject;
            Collection targetObjects = null;
            targetObjects = (Collection)findTargetObject(objectSelection);
            if (targetObjects != null) {
                Iterator iter = targetObjects.iterator();
                while (iter.hasNext()) {
                    targetObject = (StudentCourse)iter.next();
                    disconnect(targetObject,clientParentObject,dbParentObject,ctx,session);
                }
            }
            rootList.add(rootObject[0]);
        }
        return rootList;
    }

    /**
     * Disconnect a single <code>StudentCourse</code> object from its parent <code>Course object.
     *
     * @param targetObject The <code>StudentCourse</code> object as sent from the client.
     * @param clientParentObject The <code>Course</code> object as sent from the client.
     * @param dbParentObject The <code>Course</code> object as found in the database.
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
        public void disconnect(StudentCourse targetObject,Course clientParentObject,Course dbParentObject,ClientContext ctx,Session session) {
        StudentCourse resultObject = null;
        if (hookDisconnectStart(getCurrentObjectSelection(),targetObject,ctx,session)) {
            targetObject.setCourse(dbParentObject);
            resultObject = findSingle(targetObject,getCurrentObjectSelection().getTargetMainKey(),getCurrentObjectSelection().getFindData(),ctx,session);
            disconnectSingle(resultObject,dbParentObject,ctx,session);
        }
        hookDisconnectEnd(getCurrentObjectSelection(),resultObject,ctx,session);
    }

    /**
     * Disconnect a single <code>StudentCourse</code> object from its parent Course in the database.
     *
     * @param dbChildObject The <code>StudentCourse</code> object as found in the database
     * @param dbParentObject The <code>Course</code> object as found in the database
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>.
     */
    public void disconnectSingle(StudentCourse dbChildObject,Course dbParentObject,ClientContext ctx,Session session) {
        if (hookDisconnectSingleStart(dbChildObject,dbParentObject,ctx,session)) {
            if (dbParentObject != null && dbChildObject != null) {
                dbChildObject.setCourse(null);
                dbParentObject.getStudentCourses().remove(dbChildObject);
            }
        }
        hookDisconnectSingleEnd(dbChildObject,dbParentObject,ctx,session);
    }
   
    /**
     * This method is part of the <code>Manager</code> Interface and gets the target <code>StudentCourse</code> object the database.
     *
     * @param objectSelection The <code>ObjectSelection</code> containing the data from the client.
     * @param navigation
     * @param ctx The <code>ClientContext</code> desciption.
     * @param session The <code>DataAccess</code> <code>Session</code>
     * @return Object
     */
    public Object get(ObjectSelection objectSelection, ENavigation navigation, ClientContext ctx, Session session) {
        return null;
    }
}
